---
title: <center><font size="6"><b>Ontogeny of an interactive call-and-response system in Spix’s disc-winged bats</b></font></center>
subtitle: <center><font size="4"><b>Acoustic and statistical analysis</b></font></center>
author: <center><font size="4"> Marcelo Araya-Salas, Hector Andrés Hernández-Pinsón, Nazareth Rojas, Gloriana Chaverri</font></center>
date: <center>`r format(Sys.Date(), "%d-%m-%Y")`</center>
output:
  html_document:
    code_folding: show
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: no
      smooth_scroll: no
fontsize: 12pt 
editor_options: 
  chunk_output_type: console
---

This document contains all the code necessary to replicate the acoustic and statistical analyses from:

- Araya-Salas M, A Hernández-Pinsón N Rojas , G Chaverri. 2020. ***Ontogeny of an interactive call-and-response system in Spix’s disc-winged bats.*** Animal Behaviour.

---

<div class="alert alert-info">

The acoustic data has been provided as an R object in the [extended selection table](https://marce10.github.io/2018/05/15/Extended_selection_tables.html) format (generated by the R package [warbleR](https://CRAN.R-project.org/package=warbleR)). The data can be downloaded from these links:

- [Inquiry calls extended selection table](https://ndownloader.figshare.com/files/21167052)

- [Response calls extended selection table](https://ndownloader.figshare.com/files/21189891)


All original recordings and associated data files have been made available on [figshare](figshare.com):

- Araya-Salas, Marcelo; Rojas Rojas, Nazareth; Pinson, Hector Andres Hernandez  & Chaverri, Gloriana (2020): Supplementary materials: *Ontogeny of an interactive call-and-response system in Spix’s disc-winged bats.* PART 1. figshare. Dataset. https://doi.org/10.6084/m9.figshare.11651772.v1

- Araya-Salas, Marcelo; Rojas Rojas, Nazareth; Pinson, Hector Andres Hernandez & Chaverri, Gloriana (2020): Supplementary materials: *Ontogeny of an interactive call-and-response system in Spix’s disc-winged bats.* PART 2. figshare. Dataset. https://doi.org/10.6084/m9.figshare.11770938

</div>

---

First you need to install and/or load packages. The following code will load packages and install those that have not been previously installed:

```{r clean session, eval = TRUE, echo=FALSE}

#clean session
rm(list = ls())

# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))

```

```{r packages 2, warning = FALSE, echo = TRUE, eval = FALSE}

## vector with package names
x <- c("warbleR", "pbapply", "parallel", "ggplot2", "viridis", "corrplot", "caret", "ranger", "MASS", "MCMCglmm", "MuMIn", "reshape2", "coda")

aa <- lapply(x, function(y) {
  
  # check if installed, if not then install 
  if (!y %in% installed.packages()[,"Package"]) 
    install.packages(y) 

  # load package
  try(require(y, character.only = T), silent = T)
})

```


```{r packages, message=FALSE, warning = FALSE, echo = FALSE, eval = TRUE}

## add 'developer/' to packages to be installed from github
x <- c("marce10/warbleR", "pbapply", "parallel", "ggplot2", "viridis", "corrplot", "caret", "ranger", "MASS", "kableExtra", "MCMCglmm", "MuMIn", "reshape2", "coda")

aa <- lapply(x, function(y) {
  
  # get pakage name
  pkg <- strsplit(y, "/")[[1]]
  pkg <- pkg[length(pkg)]
  
  # check if installed, if not then install 
  if (!pkg %in% installed.packages()[,"Package"])  {

      if (grepl("/", y))  devtools::install_github(y, force = TRUE) else
    install.packages(y) 
    }

  # load package
  try(require(pkg, character.only = T), silent = T)
})
```

Set parameters and variable names for later use:  
```{r functions and parameters, eval = TRUE, echo = TRUE}

# define number of iterations for MCMCglmm models
itrns <- 100000

# parameter names for response calls
rsp.prms <- c("mean_freq", "entropy", "skewness", "num_syllables", "syll_duration", "syll_rate", "PC1_consistency")

# parameter names for inquiry calls
inq.prms <- c("call_duration", "mean_freq", "entropy", "freq_range",  "modulation_index", "freq_slope")

# color palette for plots
cols <- viridis(10, alpha = 0.6)
cols.inf <- inferno(10, alpha = 1)
cols.a1 <- viridis(10, alpha = 1)

# color for corrplot
col.crrplt <- colorRampPalette(c(cols.a1[1:2], rep("white", 1), cols.a1[6:7]))(100)

# for ggplot significance lines
dif.range <- function(x, na.rm = TRUE) max(x, na.rm = na.rm) - min(x, na.rm = na.rm)

# ggplot2 theme
theme_set(theme_classic(base_size = 14))

# position of points in ggplot2 
pos <- position_dodge(width= 0.5)

# repetitions for classification routine
reps <- 100
```

## Acoustic analysis

Read "extended selection tables" (RDS files) containing both metadata and acoustic data for inquiry and response calls and measure spectrographic parameters and statistical descriptors of Mel cepstral coefficients (MFCCs) using the `specan()` ` mfcc_stats()` functions, respectively, from [warbleR](https://CRAN.R-project.org/package=warbleR): 


```{r measure acoustic parameters, eval = FALSE, echo = TRUE}

# inquiry calls extended selection table
est.inq <- readRDS("ext_sel_tab_inquiry.RDS")

# response calls extended selection table
est.rsp <- readRDS("ext_sel_tab_response.RDS")

# resample at 400 kHz
est.inq <- resample_est(X = est.inq, samp.rate = 375)
est.rsp <- resample_est(X = est.rsp, samp.rate = 375)

# set global options for warbleR package functions
warbleR_options(parallel = parallel::detectCores() - 1, bp = "frange", fast = FALSE, threshold = 15, ovlp = 90)

# get spectral parameters for inquiry calls
sp.inq <- specan(est.inq, wl = 300)

# measure mel cepstral coef stats
mfcc.inq <- mfcc_stats(X = est.inq, wl = 300, nbands = 10)

# get spectral parameters for response calls
sp.rsp <- specan(X = est.rsp, wl = 600)

# measure mel cepstral coef stats
mfcc.rsp <- mfcc_stats(X = est.rsp, wl = 80, nbands = 10)

# remove columns that won't be used
sp.rsp$top.freq <- sp.rsp$bottom.freq <- sp.inq$top.freq <- sp.inq$bottom.freq <- NULL

# put together mfcc and spectral parameters
sp.inq <- merge(sp.inq, mfcc.inq, by = c("sound.files", "selec"))

# add metadata to measurements inquiry calls
sp.inq <- merge(sp.inq, est.inq[ ,c("sound.files", "selec", "sex", "age.class", "indiv", "age", "group")], by = c("sound.files", "selec"))

# put together mfcc and spectral parameters
sp.rsp <- merge(sp.rsp, mfcc.rsp, by = c("sound.files", "selec"))

# add metadata to measurements response calls
sp.rsp <- merge(sp.rsp, est.rsp[ ,c("sound.files", "selec", "start", "end", "call", "sex", "age.class", "indiv", "age", "group")], by = c("sound.files", "selec"))

# rename parameters to be used in stats
names(sp.inq)[names(sp.inq) %in% c("duration", "meanfreq", "entropy", "dfslope", "dfrange", "modindx")] <- inq.prms

```

```{r save measurements inquiry, eval = FALSE, echo = FALSE}

write.csv(sp.inq, "./suppl_mat/Spectral parameters inquiry calls.csv", row.names = FALSE)

```

```{r find best looking spectrograms, eval = FALSE, echo = FALSE}

#### inquiry calls ####  
est.inq <- readRDS("./suppl_mat/ext_sel_tab_inquiry.RDS")

# spectral parameters 
sp.inq <- read.csv("./suppl_mat/Spectral parameters inquiry calls.csv", stringsAsFactors = FALSE)

# signal to noise ratio
est.inq.SNR <- sig2noise(X = est.inq, mar = mean(est.inq$end - est.inq$start) / 2)

# add spectral parameters
est.inq.SNR <- merge(est.inq.SNR, sp.inq[, c("sound.files", "call_duration", "mean_freq")], by = "sound.files")

# select inquiry calls based on SNR
est.inq.SNR <- est.inq.SNR[est.inq.SNR$SNR > quantile(est.inq.SNR$SNR, 0.25), ]

# table(est.inq.SNR$age.class)


# scale duration and frequency
est.inq.SNR$cntr.dur[est.inq.SNR$age.class == "adults"] <- scale(est.inq.SNR$call_duration[est.inq.SNR$age.class == "adults"])

est.inq.SNR$cntr.dur[est.inq.SNR$age.class == "juveniles"] <- scale(est.inq.SNR$call_duration[est.inq.SNR$age.class == "juveniles"])

est.inq.SNR$cntr.dur <- abs(est.inq.SNR$cntr.dur)

est.inq.SNR$cntr.frq[est.inq.SNR$age.class == "adults"] <- scale(est.inq.SNR$mean_freq[est.inq.SNR$age.class == "adults"])

est.inq.SNR$cntr.frq[est.inq.SNR$age.class == "juveniles"] <- scale(est.inq.SNR$mean_freq[est.inq.SNR$age.class == "juveniles"])

est.inq.SNR$cntr.frq <- abs(est.inq.SNR$cntr.frq)

est.inq.SNR$cntr.snr[est.inq.SNR$age.class == "adults"] <- scale(est.inq.SNR$SNR[est.inq.SNR$age.class == "adults"])

est.inq.SNR$cntr.snr[est.inq.SNR$age.class == "juveniles"] <- scale(est.inq.SNR$SNR[est.inq.SNR$age.class == "juveniles"])

slctd.inq <- est.inq.SNR[ave(-(est.inq.SNR$cntr.dur + est.inq.SNR$cntr.frq + est.inq.SNR$cntr.snr), est.inq.SNR$age.class, FUN = rank) <= 2, ]

slctd.inq <- fix_extended_selection_table(X = slctd.inq[c(2, 4), ], est.inq)

slctd.inq

slctd.inq <- warbleR::resample_est(X = slctd.inq, samp.rate = 400)

spectrograms(X = slctd.inq, dest.path = "./spectrograms/for_paper/", mar = 0.03, title.labels = c("sound.files","age.class"), flim = c(10, 50))

# extract waves
inq.adl <- read_wave(X = slctd.inq, index = which(slctd.inq$age.class == "adults")[1], from = 0.09, to = 0.17)

inq.juv <- read_wave(X = slctd.inq, index = which(slctd.inq$age.class == "juveniles")[1], from = 0.09, to = 0.17)


### Response calls

# response calls extended selection table
est.rsp <- readRDS("./suppl_mat/ext_sel_tab_response.RDS")

sp.rsp.cll <- read.csv("./suppl_mat/Spectral parameters by call response calls.csv", stringsAsFactors = FALSE)

est.rsp.SNR <- sig2noise(X = est.rsp, mar = mean(est.rsp$end - est.rsp$start) / 2)

cll.SNR <- song_param(est.rsp.SNR, song_colm = "call", mean_colm = "SNR", na.rm = TRUE)

cll.SNR <- cll.SNR[cll.SNR$SNR > quantile(cll.SNR$SNR, 0.25), ]

# add skewness
est.rsp.SNR <- merge(est.rsp.SNR, sp.rsp.cll[, c("sound.files", "skewness", "syll_duration")], by = "sound.files")

est.rsp.SNR$SNR <- NULL

# add call SNR
est.rsp.SNR <- merge(est.rsp.SNR, cll.SNR[, c("sound.files", "SNR", "call", "num.elms")], by = c("sound.files", "call"))

# scale duration and skewness
est.rsp.SNR$cntr.num.elms[est.rsp.SNR$age.class == "adults"] <- scale(est.rsp.SNR$num.elms[est.rsp.SNR$age.class == "adults"])

est.rsp.SNR$num.elms[est.rsp.SNR$age.class == "juveniles"] <- scale(est.rsp.SNR$num.elms[est.rsp.SNR$age.class == "juveniles"])

est.rsp.SNR$cntr.num.elms <- abs(est.rsp.SNR$cntr.num.elms)

est.rsp.SNR$cntr.snr[est.rsp.SNR$age.class == "adults"] <- scale(est.rsp.SNR$SNR[est.rsp.SNR$age.class == "adults"])

est.rsp.SNR$cntr.snr[est.rsp.SNR$age.class == "juveniles"] <- scale(est.rsp.SNR$SNR[est.rsp.SNR$age.class == "juveniles"])

est.rsp.SNR$rank <- ave(-(est.rsp.SNR$cntr.num.elms + est.rsp.SNR$cntr.snr), est.rsp.SNR$age.class, FUN = rank)

est.rsp.SNR$sf.call <- paste(est.rsp.SNR$sound.files, est.rsp.SNR$call, sep = "-")

sum.rank.adlts <- tapply(est.rsp.SNR$rank[est.rsp.SNR$age.class == "adults"], est.rsp.SNR$sf.call[est.rsp.SNR$age.class == "adults"], sum)

sum.rank.jvnls <- tapply(est.rsp.SNR$rank[est.rsp.SNR$age.class == "juveniles"], est.rsp.SNR$sf.call[est.rsp.SNR$age.class == "juveniles"], sum)

slctd.rsp <- est.rsp.SNR[est.rsp.SNR$sf.call %in% c(names(sort(sum.rank.adlts)[1:2]), names(sort(sum.rank.jvnls)[1:2])), ]

slctd.rsp <- fix_extended_selection_table(X = slctd.rsp, est.rsp)


specreator(slctd.rsp, flim = c(30, 190), ovlp = 90, by.song = "call", xl = 3, fast.spec = FALSE, dest.path = "./spectrograms/for_paper/", title.labels = c("sound.files", "age.class"))

slctd.rsp <- est.rsp.SNR[est.rsp.SNR$sf.call %in% c("T2018-03-28_09-10-15_0000030.wav-song_131-131", "T2018-07-23_11-18-21_0000084.wav-song_12-12"), ]

slctd.rsp <- fix_extended_selection_table(X = slctd.rsp, est.rsp)

slctd.rsp <- warbleR::resample_est(X = slctd.rsp, samp.rate = 400)

# extract waves
rsp.adl <- read_wave(X = slctd.rsp, index = which(slctd.rsp$age.class == "adults")[1], from = 0.092, to = 0.208)

rsp.juv <- read_wave(X = slctd.rsp, index = which(slctd.rsp$age.class == "juveniles")[1], from = 0.092, to = 0.18)

hf.dif <- (duration(rsp.adl) - duration(rsp.juv)) / 2

rsp.juv <- read_wave(X = slctd.rsp, index = which(slctd.rsp$age.class == "juveniles")[1], from = 0.092 - hf.dif, to = 0.18 + hf.dif)

```

```{r make spectros, eval = FALSE, echo = FALSE}

source("~/Dropbox/R_package_testing/warbleR/warbleR/R/spectro_wrblr_int2.R")
source("~/Dropbox/R_package_testing/warbleR/warbleR/R/stft_wrblr_int.R")
source("~/Dropbox/R_package_testing/warbleR/warbleR/R/filled_contour_wrblr_int.R")
source("~/Dropbox/R_package_testing/warbleR/warbleR/R/boxw_wrblr_int.R")
source("~/Dropbox/R_package_testing/warbleR/warbleR/R/rectw_wrblr_int.R")

adl <- pastew(wave1 = normalize(rsp.adl), wave2 = (normalize(inq.adl)), output = "Wave")

juv <- pastew(wave1 = normalize(rsp.juv), wave2 = (normalize(inq.juv)), output = "Wave")


dev.off()

jpeg(filename = "spectrogram_figure.jpeg", width = 1200, quality = 100, res = 300, pointsize = 4)

mt <- rbind(
  c(0, 0.05, 0, 0.82), # freq label
  c(0.05, 0.94, 0.5, 0.82), # top spectro
c(0.05, 0.94, 0, 0.5), # bottom spectro
c(0.94, 0.98, 0.16, 0.5), # adult label
c(0.94, 0.98, 0.5, 0.821), # juvenile label
c(0.082, 0.425, 0.82, 0.9), # inquiry
c(0.425, 0.98, 0.82, 0.9) # response
               )

split.screen(mt)

pal <- reverse.gray.colors.2
ovlp <- 9
flim.inq <- flim.rsp <- c(10, 120)

# position of line dividing spectros
abl <- 0.0785

# backgrond color of labels
bg.col <- adjustcolor(cols.a1[8], alpha.f = 0.5)

screen(1)

mtext("Frequency (kHz)", side = 2, line = 2.1, at =  0.7)

screen(2)

par(mar = c(0, 2, 0, 0))

spectro_wrblr_int2(juv, wl = 270, ovlp = ovlp, grid = FALSE, collevels = seq(-45, 0, 1), palette = pal, flim = flim.inq, axisX = FALSE, axisY = FALSE, tlab = NULL, flab = NULL)

axis(2, at = seq(10, 110, by = 20), labels = c("", 30, 50, 70, 90, 110))

abline(v = abl, lty = 1)

screen(3)

par(mar = c(4, 2, 0, 0))


spectro_wrblr_int2(adl, wl =270, ovlp = ovlp, grid = FALSE, collevels = seq(-45, 0, 1), palette = pal, flim = flim.inq, axisY = FALSE, flab = NULL, tlab = NULL, axisX = FALSE)

mtext("Time (ms)", side = 1, line = 2)

axis(2, at = seq(10, 110, by = 20), labels = c("", 30, 50, 70, 90, 110))

axis(1, at = seq(0, 0.2, by = 0.05), labels = seq(0, 0.2, by = 0.05) * 1000)

abline(v = abl, lty = 1)

par(bg = bg.col)

# par(bg = "white")

#font color
fcol <- "black"
cx <- 1

screen(4)

boxw_wrblr_int(xys = mt[4, ], bty = "o", lwd = 0)

mtext("Adults", side = 2, line = 2.5, font = 2, col = fcol, cex = cx)

text(x = 0, y = 1, "StrengthStrengthStrengthStrengthStrengthStrength", cex = 10, str =0)

screen(7)

boxw_wrblr_int(xys = mt[7, ], bty = "o", lwd = 0)

mtext("Response", side = 3, line = 2.7, font = 2, col = fcol, cex = cx)


screen(5)

boxw_wrblr_int(xys = mt[5, ], bty = "o", lwd = 0)

mtext("Juveniles", side = 2, line = 2.5, font = 2, srt = 90, col = fcol, cex = cx)


screen(6)

boxw_wrblr_int(xys = mt[6, ], bty = "c", lwd = 0)

mtext("Inquiry", side = 3, line = 2.7, font = 2, col = fcol, cex = cx)

close.screen(all.screens = TRUE)

dev.off()
```

Response calls measurements were made at the syllable level. Call level parameters must be measured using the `song_param()` function from [warbleR](https://CRAN.R-project.org/package=warbleR):
```{r call level parameters, eval = FALSE, echo = TRUE}

# measure call parameters
sp.rsp.cll <- song_param(sp.rsp, song_colm = "call", sd = TRUE, mean_colm = c("duration", "meanfreq", "entropy", "modindx", "dfrange", "skew", grep("kurt.cc|mean.d|var.d1|median.c|min.cc|max.cc|skew.cc", names(sp.rsp), value = TRUE)), na.rm = TRUE)

```

Add coefficient of variation for selected parameters and then calculate PCA on call consistency: 
```{r add CVs to response calls, eval = FALSE}

# calculate Coefficient of variation
sp.rsp.cll$cv.duration <- sp.rsp.cll$duration / sp.rsp.cll$sd.duration
sp.rsp.cll$cv.meanfreq <- sp.rsp.cll$meanfreq / sp.rsp.cll$sd.meanfreq
sp.rsp.cll$cv.entropy <- sp.rsp.cll$entropy / sp.rsp.cll$sd.entropy
sp.rsp.cll$cv.modindx <- sp.rsp.cll$modindx / sp.rsp.cll$sd.modindx
sp.rsp.cll$cv.skew <- sp.rsp.cll$skew / sp.rsp.cll$sd.skew
sp.rsp.cll$cv.dfrange <- sp.rsp.cll$dfrange / sp.rsp.cll$sd.dfrange
sp.rsp.cll$cv.gap.duration <- sp.rsp.cll$gap.duration / sp.rsp.cll$sd.gap.duration

# add metadata to call level parameters
sp.rsp.cll <- merge(sp.rsp.cll, sp.rsp[!duplicated(sp.rsp[, c("sound.files", "call")]), c("sound.files", "call", "indiv", "sex", "age", "age.class", "group")], by = c("sound.files", "call"))

```

```{r read data, eval = TRUE, echo = FALSE}

sp.rsp.cll <- read.csv("./suppl_mat/Spectral parameters by call response calls.csv", stringsAsFactors = FALSE)

sp.inq <- read.csv("./suppl_mat/Spectral parameters inquiry calls.csv", stringsAsFactors = FALSE)
```

Calculate PCA for representing call consistency: 
```{r PCA consistency, eval = TRUE, fig.height = 4}

## run PCA on complete cases of CV variables
pca <- prcomp(sp.rsp.cll[complete.cases(sp.rsp.cll[,c("cv.duration", "cv.meanfreq", "cv.entropy", "cv.dfrange", "cv.skew", "cv.gap.duration")]), c("cv.duration", "cv.meanfreq", "cv.entropy", "cv.dfrange", "cv.skew", "cv.gap.duration")], scale. = TRUE)

# check variable contribution to PCs
pca.contr <- data.frame(PC = paste0("PC", 1:6), t(summary(pca)$importance))

ggplot(pca.contr, aes(x = PC, y = Cumulative.Proportion)) +
  geom_col(fill = cols[6]) + ylab("Cumulative contribution") + 
  geom_text(aes(x=PC,y=Cumulative.Proportion,label= round(Cumulative.Proportion, 2)),vjust=0) 
```

Check variable contribution to PCs and save PC1:
```{r pca contributions, eval = TRUE, fig.height=6}
# Add first PC to call level parameters
sp.rsp.cll$PC1 <- NA 

sp.rsp.cll$PC1[complete.cases(sp.rsp.cll[,c("cv.duration", "cv.meanfreq", "cv.entropy", "cv.dfrange", "cv.skew", "cv.gap.duration")])] <- pca$x[, "PC1"] 

# check PCA loadings
loads <- data.frame(PC = rep(paste0("PC", 1:6), each = 6), var = rep(c("CV_duration", "CV_mean_freq", "CV_entropy", "CV_freq_range", "CV_skewness", "CV_gap_duration"), 6), score = c(pca$rotation))

ggplot(loads, aes(x = var, y = score)) + 
  geom_col(fill = cols[8]) +
  facet_wrap( ~ PC, nrow = 3) +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) 

```

Rename response call parameters:
```{r rename rsp, eval = FALSE}

  names(sp.rsp.cll)[names(sp.rsp.cll) %in% c("meanfreq", "entropy", "skew", "num.elms", "elm.duration", "song.rate", "PC1")] <- rsp.prms

```

```{r save measurements response, eval = FALSE, echo = FALSE}

write.csv(sp.rsp.cll, "./suppl_mat/Spectral parameters by call response calls.csv", row.names = FALSE)

```

Correlation on selected acoustic parameters for response calls:
```{r cor selected param rsp, eval = TRUE, echo = TRUE}

#correlation among variables
cm <- cor(sp.rsp.cll[, rsp.prms], use = "pairwise.complete.obs")

corrplot.mixed(corr = cm, order = "hclust", tl.pos = "lt", upper = "ellipse", upper.col = col.crrplt, lower.col = col.crrplt, 
tl.col = "black")


```

Correlation on selected acoustic parameters for inquiry calls:
```{r cor selected param inq, eval = TRUE, echo = TRUE}

#correlation among variables
cm <- cor(sp.inq[,  inq.prms], use = "pairwise.complete.obs")

corrplot.mixed(corr = cm, order = "hclust", tl.pos = "lt", upper = "ellipse", upper.col = col.crrplt, lower.col = col.crrplt, 
tl.col = "black")

```

## Descriptive statistics

Youngest age at which RESPONSE calls were produced:

- mean youngest age male: 
```{r} 
round(mean(tapply(sp.rsp.cll$age[sp.rsp.cll$sex == "M" & sp.rsp.cll$age.class == "juveniles"], sp.rsp.cll$indiv[sp.rsp.cll$sex == "M" & sp.rsp.cll$age.class == "juveniles"], min, na.rm = TRUE), na.rm = TRUE), 2)
```

- mean youngest age female: 
```{r} 
round(mean(tapply(sp.rsp.cll$age[sp.rsp.cll$sex == "F" & sp.rsp.cll$age.class == "juveniles"], sp.rsp.cll$indiv[sp.rsp.cll$sex == "F" & sp.rsp.cll$age.class == "juveniles"], min, na.rm = TRUE), na.rm = TRUE), 2)
```

- minimum youngest age male: 
```{r} 
round(min(sp.rsp.cll$age[sp.rsp.cll$sex == "M" &  sp.rsp.cll$age.class == "juveniles"]), 2)
```

- minimum youngest age female: 
```{r} 
 round(min(sp.rsp.cll$age[sp.rsp.cll$sex == "F" &  sp.rsp.cll$age.class == "juveniles"]), 2)
```

Youngest age at which INQUIRY calls were produced (only for males as females were not aged - no forearm information):

- mean youngest age male: 
```{r, warning=FALSE} 
m.age.inq.male <- tapply(sp.inq$age[sp.inq$sex == "M" & sp.inq$age.class == "juveniles"], sp.inq$indiv[sp.inq$sex == "M" & sp.inq$age.class == "juveniles"], min, na.rm = TRUE)

round(mean(m.age.inq.male[!is.infinite(m.age.inq.male)], na.rm = TRUE), 2)
```

- minimum youngest age male: 
```{r, warning=FALSE} 
m.age.inq.male <- tapply(sp.inq$age[sp.inq$sex == "M" & sp.inq$age.class == "juveniles"], sp.inq$indiv[sp.inq$sex == "M" & sp.inq$age.class == "juveniles"], min, na.rm = TRUE)

round(min(m.age.inq.male[!is.infinite(m.age.inq.male)], na.rm = TRUE), 2)
```


## Statistical analysis

## Response call ontogeny

### Juveniles

Bayesian MCMC generalized linear models on response call acoustic parameters with individual as a random effect and age or sex as predictors. 3 models compared for each acoustic parameter: 

1. only age as predictor:
$$Acoustic\ parameter \sim age + (1 | indiv)$$
2. age, sex and their interaction as predictors: 
$$Acoustic\ parameter \sim age + sex + age:sex + (1 | indiv)$$
3. Null model with no predictor:
$$Acoustic\ parameter \sim 1 + (1 | indiv)$$

A loop is used to run these 3 models for each selected acoustic parameters. Each model is replicated 3 times with starting values sampled from a Z-distribution ("start" argument in MCMCglmm()). Parameters are scaled (i.e. z-transformed) to obtained standardized effect sizes (within the loop). Diagnostic plots for MCMC model performance are shown at the end of this report.

```{r stats MCMCglmm 3 times, eval = FALSE, echo = TRUE, fig.height=10}

# Selecting between with and without interaction
mods.rsp.ontog <- pblapply(rsp.prms, function(x){  
 
  # choose complete cases and data for juveniles
  X <- sp.rsp.cll[complete.cases(sp.rsp.cll[ , x]) & sp.rsp.cll$age.class == "juveniles", ]
  
  # scale and center response
  X[, x] <- scale(X[, x])
  
  # mean-center predictor
  X$age <- X$age - mean(X$age)
  
  # replicate each one 3 times
  m.age.sex <- replicate(3, MCMCglmm(formula(paste(x, " ~ age + sex + age:sex")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns, start = list(QUASI = FALSE)), simplify = FALSE)
  
  m.age <- replicate(3, MCMCglmm(formula(paste(x, " ~ age")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
  
  m.null <- replicate(3, MCMCglmm(formula(paste(x, " ~ 1")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
  
  ms <- model.sel(m.age.sex[[1]], m.age[[1]], m.null[[1]], rank="DIC")
  
  rownames(ms) <-  gsub("[[1]]", "",rownames(ms), fixed = TRUE)
  
  mds <- list(model.tab = ms, m.age.sex = m.age.sex, m.age = m.age, m.null = m.null)

  return(mds)
})

names(mods.rsp.ontog) <- rsp.prms

# mods.rsp.ontog


```

```{r save mcmc results, eval=FALSE, echo=FALSE}

saveRDS(mods.rsp.ontog, "./suppl_mat/MCMCglmm models response ontogeny.RDS")
  
```

Model selection results:

```{r mod sel rsp ontog 1, eval = FALSE, echo = TRUE, results='asis'}

# put all model selection results in a list
mod.list <- lapply(1:length(mods.rsp.ontog), function(i)  data.frame(response = names(mods.rsp.ontog)[i], predictors = rownames(mods.rsp.ontog[[i]][[1]]), mods.rsp.ontog[[i]][[1]], stringsAsFactors = FALSE))

# make a data frame with all results
mod.sel.tab <- do.call(rbind, mod.list)

# fix predictor names
mod.sel.tab$predictors <- gsub("m.", "",  mod.sel.tab$predictors)

mod.sel.tab$predictors <- gsub("age.sex", "age + sex + age:sex",  mod.sel.tab$predictors)

```

```{r mod sel rsp ontog, eval = TRUE, echo = FALSE, results='asis'}

mods.rsp.ontog <- readRDS("./suppl_mat/MCMCglmm models response ontogeny.RDS")

# put all model selection results in a list
mod.list <- lapply(1:length(mods.rsp.ontog), function(i)  data.frame(response = names(mods.rsp.ontog)[i], predictors = rownames(mods.rsp.ontog[[i]][[1]]), mods.rsp.ontog[[i]][[1]], stringsAsFactors = FALSE))

# make a data frame with all results
mod.sel.tab <- do.call(rbind, mod.list)

# fix predictor names
mod.sel.tab$predictors <- gsub("m.", "",  mod.sel.tab$predictors)

mod.sel.tab$predictors <- gsub("age.sex", "age + sex + age:sex",  mod.sel.tab$predictors)

# mod.sel.tab[is.na(mod.sel.tab)] <- ""

options(knitr.kable.NA = '')

df1 <- knitr::kable(mod.sel.tab[, c("response", "predictors", "df", "logLik", "DIC", "delta", "weight")], row.names = FALSE, escape = FALSE, format = "html")

df1 <- row_spec(df1, which(mod.sel.tab$delta== 0), background = adjustcolor(cols[9], alpha.f = 0.3))
  
kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

```

Select the best model for each parameter and extract effect sizes:
```{r sel model, eval = TRUE, echo = TRUE}

# select best models based on BIC
best.mods.rsp.ontog <- pblapply(mods.rsp.ontog, function(X){ 
  
  # if best model was at least 2 BIC units higher than null
  if (X[[1]]["m.null", "delta"] > 2) return(X[[rownames(X[[1]])[1]]][[1]]) else
      return(NA) # else if models were as good as null model return NA
  })

# rename
names(best.mods.rsp.ontog) <- names(mods.rsp.ontog)

# remove the NA ones (the ones in which the null model was the best)
best.mods.rsp.ontog <- best.mods.rsp.ontog[sapply(best.mods.rsp.ontog, class) == "MCMCglmm"]
  
# extract fixed effect size
out <- lapply(1:length(best.mods.rsp.ontog), function(x){
  
  # fixed effects
  fe <- summary(best.mods.rsp.ontog[[x]])$solutions

  # Confidence intervals
  ci <- HPDinterval(best.mods.rsp.ontog[[x]]$Sol)
  
  # sample sizes  
  obs <- sp.rsp.cll[complete.cases(sp.rsp.cll[ , names(best.mods.rsp.ontog)[x]]) & sp.rsp.cll$age.class == "juveniles", ]
  
  # put results together in a data frame
  res <- data.frame(
    stringsAsFactors = FALSE, 
    # response variable name
    response = names(best.mods.rsp.ontog)[x], 
    # predictor name
    predictor = rownames(ci)[2:nrow(ci)], effect_size = fe[-1, "post.mean"], 
    # lower confident interval
    CI_2.5 = ci[2:nrow(ci), 1], 
    # upper confident interval
    CI_97.5 = ci[2:nrow(ci), 2], 
    # p value
    pMCMC  = fe[-1, "pMCMC"], 
    #intercept
    intercept = fe[1, "post.mean"],
    # number of individuals
    n.indv = length(unique(obs$indiv)), 
    # number of males
    n.males = length(unique(obs$indiv[obs$sex == "M"])), 
    # number of females
    n.females = length(unique(obs$indiv[obs$sex == "F"])), 
    # number of observations
    n.obs = nrow(obs), 
    # number of male calls
    obs.males = length(obs$indiv[obs$sex == "M"]), 
    # number of female calls
    obs.females = length(obs$indiv[obs$sex == "F"]), 
    # mean response
    mean = mean(obs[, names(best.mods.rsp.ontog)[x]], na.rm = TRUE), 
    # standard deviation of response
    sd = sd(obs[, names(best.mods.rsp.ontog)[x]], na.rm = TRUE)
    )
  
 return(res)
})

# put effect sizes in a single data frame 
es.rsp.ontog <- do.call(rbind, out)
rownames(es.rsp.ontog) <- 1:nrow(es.rsp.ontog)


```

```{r effect sizes ontogeny, eval = TRUE, echo = FALSE}

md <- es.rsp.ontog[, !grepl("mean|sd", names(es.rsp.ontog))]

md$CI_2.5 <- round(md$CI_2.5, 4)
md$CI_97.5 <- round(md$CI_97.5, 4)

#exlude only sex
md <- md[md$predictor != "sexM", ]

# get the ones that do not overlap with 0
mltp <- md$CI_2.5 * md$CI_97.5

md$CI_2.5 <- ifelse(mltp > 0, cell_spec(md$CI_2.5, "html", color ="white", background = cols[7], bold = T,  font_size = 12),  cell_spec(md$CI_2.5, "html"))

md$CI_97.5 <- ifelse(mltp > 0, cell_spec(md$CI_97.5, "html", color ="white", background = cols[7], bold = T,  font_size = 12),  cell_spec(md$CI_97.5, "html"))

df1 <- knitr::kable(md, row.names = FALSE, escape = FALSE, format = "html", digits = c(4))

df1 <- row_spec(df1, which(mltp > 0), background = adjustcolor(cols[9], alpha.f = 0.3))
  
kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

```

```{r save models ontogeny, eval = FALSE, echo = FALSE}

# save effect sizes
write.csv(es.rsp.ontog, "./suppl_mat/Effect sizes MCMCglmm models call ontogeny.csv", row.names = FALSE)
  
saveRDS(best.mods.rsp.ontog, "./suppl_mat/best MCMCglmm models response ontogeny.RDS")

```

Plot effect sizes of age by response variable (only models that improved fit compared to the null models are evaluated):

```{r effect sizes plot only age MCMCglmm, eval = FALSE, echo = TRUE}

ggplot(es.rsp.ontog[es.rsp.ontog$predictor == "age", ], aes(x = response, y = effect_size)) + 
  geom_hline(yintercept = 0, lty = 2) +
  geom_point(col = cols[7], size = 2.5) +
  geom_errorbar(aes(ymin=CI_2.5, ymax=CI_97.5), width=.05, col = cols[7], size = 1.2) +
  coord_flip()

```

```{r read data effect sizes plot only age MCMCglmm, eval = TRUE, echo = FALSE, fig.height = 3}

es.rsp.ontog <- read.csv("./suppl_mat/Effect sizes MCMCglmm models call ontogeny.csv", stringsAsFactors = FALSE)

ggplot(es.rsp.ontog[es.rsp.ontog$predictor == "age", ], aes(x = response, y = effect_size)) + 
  geom_hline(yintercept = 0, lty = 2) +
  geom_point(col = cols[7], size = 2.5) +
  geom_errorbar(aes(ymin=CI_2.5, ymax=CI_97.5), width=.05, col = cols[7], size = 1.2) +
  coord_flip()

```

Plot effect sizes of age-sex interaction by response variable (showing the difference in slope of males compare to females):

```{r effect sizes plot interaction MCMCglmm, eval = TRUE, echo = TRUE, fig.height = 3}

ggplot(es.rsp.ontog[es.rsp.ontog$predictor == "age:sexM", ], aes(x = response, y = effect_size)) + 
  geom_hline(yintercept = 0, lty = 2) +
  geom_point(col = cols[7], size = 2.5) +
  geom_errorbar(aes(ymin=CI_2.5, ymax=CI_97.5), width=.05, col = cols[7], size = 1.2) +
  coord_flip()

```

Scatter plots with original units:
```{r scatterplots OLD NOT USED, eval = FALSE, echo = FALSE, fig.height = 13, fig.width = 14, warning=FALSE}

# subset response call parameters for juveniles
sp.rsp.cll.j <- melt(sp.rsp.cll[sp.rsp.cll$age.class == "juveniles", c(rsp.prms, "sex", "age")], id.vars=c("sex", "age"))

# convert to ms
sp.rsp.cll.j$value[sp.rsp.cll.j$variable == "syll_duration"] <- sp.rsp.cll.j$value[sp.rsp.cll.j$variable == "syll_duration"] * 1000

# Plot relationship from above model
ggplot(sp.rsp.cll.j, aes(x = age, y = value, color = sex)) +
  geom_point(size = 2) +
  labs(x = "Age (days)", y = NULL) +
  geom_smooth(method = "lm") +
  scale_colour_manual(name="Sex",  values = cols[c(2, 7)]) +
  facet_wrap(~ variable, ncol = 2, scales = "free_y", strip.position = "left") +
  theme_classic(base_size = 16) +
  theme(strip.background = element_blank(), strip.placement = "outside")
```

```{r scatterplots 2, eval = TRUE, echo = TRUE, fig.height = 13, fig.width = 14, warning=FALSE}

# subset response call parameters for juveniles
sp.rsp.cll.j <- melt(sp.rsp.cll[sp.rsp.cll$age.class == "juveniles", c(rsp.prms, "sex", "age")], id.vars=c("sex", "age"))

# convert to ms
sp.rsp.cll.j$value[sp.rsp.cll.j$variable == "syll_duration"] <- sp.rsp.cll.j$value[sp.rsp.cll.j$variable == "syll_duration"] * 1000

# change sex labels
sp.rsp.cll.j$sex <- ifelse(sp.rsp.cll.j$sex == "M", "Males", "Females")

# add M+F as a category for model not including sex interaction
sp.rsp.cll.j$sex[!sp.rsp.cll.j$variable %in% es.rsp.ontog$response[grepl("age:sexM", es.rsp.ontog$predictor) & es.rsp.ontog$pMCMC < 0.05]] <- "Both sexes" 

# split data by variable and sex
l.sp.rsp.cll.j <- split(sp.rsp.cll.j, f = list(sp.rsp.cll.j$variable, sp.rsp.cll.j$sex))

# extract effect size, convert to original units
data.segm <- lapply(l.sp.rsp.cll.j, function(X){

  if (any(es.rsp.ontog$response %in% X$variable)){  
    
    # creata a data frame to save results
    df <- data.frame(x = min(X$age, na.rm = TRUE), xend = max(X$age, na.rm = TRUE), mean = mean(X$age, na.rm = TRUE), variable = X$variable[1], sex = X$sex[1], stringsAsFactors = FALSE)

    # include color depending on sex
    df$col <- if (df$sex == "Females") cols.a1[2] else if (df$sex == "Males") cols.a1[9] else cols.a1[5]
    
    # extract effect size of age
    es <- es.rsp.ontog$effect_size[es.rsp.ontog$response == df$variable & es.rsp.ontog$predictor == "age"] 
    
  # if model included sex and this iteration is for males add effect size of sex to baseline effect size
  if(any(es.rsp.ontog$response == df$variable & es.rsp.ontog$predictor == "sexM") & df$sex == "Males")
    es <- es + es.rsp.ontog$effect_size[es.rsp.ontog$response == df$variable & es.rsp.ontog$predictor == "age:sexM"]
  
    #trasform back to original units
    intrcpt <- es.rsp.ontog$intercept[es.rsp.ontog$response == df$variable][1]
  
      # if model included sex and this iteration is for males add intercept of sex to baseline intercept
    if(any(es.rsp.ontog$response == df$variable & es.rsp.ontog$predictor == "sexM") & df$sex == "Males")
    intrcpt <- intrcpt + es.rsp.ontog$effect_size[es.rsp.ontog$response == df$variable & es.rsp.ontog$predictor == "sexM"]
    
    # extract SD and mean to recalculate original variables
    sdX <- es.rsp.ontog$sd[es.rsp.ontog$response == df$variable][1]
    Xmn <- es.rsp.ontog$mean[es.rsp.ontog$response == df$variable][1]
    
    # get extreme values for Y
    df$y <- (intrcpt * sdX) + Xmn + (es * (df$x - df$mean) * sdX)
    df$yend <- (intrcpt * sdX) + Xmn + (es * (df$xend - df$mean) * sdX)
    
    # fix syll duration to units in ms
    if (X$variable[1] == "syll_duration"){
      df$y <- df$y * 1000  
      df$yend <- df$yend * 1000
    }  
  } else df <- NA
  
      return(df)
      }
  )


#remove NAs
data.segm <- data.segm[sapply(data.segm, is.data.frame)]

# put data in data frame
data.segm <- do.call(rbind, data.segm)

# make sex a factor for plotting
sp.rsp.cll.j$sex <- factor(sp.rsp.cll.j$sex, levels = unique(sp.rsp.cll.j$sex)[c(1, 3, 2)])

sp.rsp.cll.j <- sp.rsp.cll.j[sp.rsp.cll.j$variable != "mean_freq", ]

# order parameters
sp.rsp.cll.j$variable <- factor(sp.rsp.cll.j$variable, levels = unique(sp.rsp.cll.j$variable)[c(6, 1:5)])

#remove mean frequency
ggplot(sp.rsp.cll.j, aes(x = age, y = value, color = sex)) +
  geom_point(size = 2) +
  labs(x = "Age (days)", y = NULL) +
  scale_colour_manual(name="Sex", values = cols[c(5, 9, 3)]) +
  facet_wrap(~ variable, ncol = 2, scales = "free_y", strip.position = "left", labeller = as_labeller(c(entropy = "Entropy", skewness = "Skewness", num_syllables = "Number of syllables", syll_duration = "Syllable duration (ms)", syll_rate = "Syllable rate", PC1_consistency = "Consistency (PC1)"))) +
  theme_classic(base_size = 20) +
  theme(legend.position = c(0.9, 0.72), legend.key.size =  unit(0.25, "in"), strip.background = element_blank(), strip.placement = "outside", legend.title = element_blank(), legend.background = element_rect(fill=alpha('white', 0))) + 
  geom_segment(data=data.segm, lineend = "square", aes(x=x,y=y,yend=yend,xend=xend), inherit.aes = FALSE, col = data.segm$col, size = 1.3) + 
  guides(colour = guide_legend(override.aes = list(size = 3))) #increase size legend points

```

### Adults vs non-volant and volant juveniles

3 age categories

- Non-volant juveniles: 4.23- 19.5 days old
- Volant juveniles: 49.9 - 65.2 days old
- Adults: ~2 years

Longitudinal data (age.class == 'juveniles') was split in 4 age categories and the 2 extremes were used (non-volant vs volant juveniles). Ages above 70 days old were excluded due to small sample sizes.

The following code organizes the data accordingly:
```{r adults vs juveniles data, eval = TRUE, echo = TRUE}

# remove juveniles order than 70 days
sub.sp.rsp.cll <- sp.rsp.cll[sp.rsp.cll$age < 70 | sp.rsp.cll$age.class == "adults", ]

# split juveniles in 4 age categories
sub.sp.rsp.cll$age.class[sub.sp.rsp.cll$age.class == "juveniles"] <- cut(sub.sp.rsp.cll$age[sub.sp.rsp.cll$age.class == "juveniles"], breaks = 4)

# remove intermediate classes
sub.sp.rsp.cll <- sub.sp.rsp.cll[sub.sp.rsp.cll$age.class %in% c(1, 4, "adults"), ]

# convert classes to labels
sub.sp.rsp.cll$age.class <- ifelse(sub.sp.rsp.cll$age.class == 1, "non-volant", ifelse(sub.sp.rsp.cll$age.class == 4, "volant", "adults")) 

```

Again, Bayesian MCMC generalized linear models on response call acoustic parameters with individual as a random effect and age category as predictor. 2 models compared for each acoustic parameter: 

1. age category as single predictor: 
$$Acoustic\ parameter \sim age.category + (1 | indiv)$$

2. Null model with no predictor:
$$Acoustic\ parameter \sim 1 + (1 | indiv)$$

A loop is used to run these 2 models for each selected acoustic parameters. Each model is replicated 3 times with starting values sampled from a Z-distribution ("start" argument in MCMCglmm()). Parameters are scaled (i.e. z-transformed) to obtained standardized effect sizes (within the loop). Diagnostic plots for MCMC model performance are shown at the end of this report.

```{r adults vs juveniles stats MCMCglmm NOT USED, eval = FALSE, echo = TRUE}

# adults vs non-volant and volant juveniles
mds.age.clss.rsp <- pblapply(rsp.prms, function(x){  
 
  # choose complete cases and data for juveniles
  X <- sub.sp.rsp.cll[complete.cases(sub.sp.rsp.cll[ , x]), ]
  
  # scale and center
  X[, x] <- scale(X[, x]) 
  
  # replicate each model 3 times
  # model age
  m.age <- replicate(3, MCMCglmm(formula(paste(x, " ~ age.class")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)

  # null model
  m.null <- replicate(3, MCMCglmm(formula(paste(x, " ~ 1")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
  
  # put together the first models
  ms <- model.sel(m.age[[1]], m.null[[1]], rank = "DIC")
  
  # rename rows so they match predictor names
  rownames(ms) <-  gsub("[[1]]", "",rownames(ms), fixed = TRUE)
  
  # save models in a list
  res <- list(model.tab = ms, m.age = m.age, m.null = m.null)
  
  return(res)
})

# add parameter name to models
names(mds.age.clss.rsp) <- rsp.prms


```

```{r adults vs juveniles by sex stats MCMCglmm, eval = FALSE, echo = TRUE}

# adults vs non-volant and volant juveniles
mds.age.clss.sex.rsp <- pblapply(rsp.prms, function(x){  
 
  # choose complete cases and data for juveniles
  X <- sub.sp.rsp.cll[complete.cases(sub.sp.rsp.cll[ , x]), ]
  
  # scale and center
  X[, x] <- scale(X[, x]) 
  
  # replicate each model 3 times
  # model age
  m.age <- replicate(3, MCMCglmm(formula(paste(x, " ~ age.class")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)

  m.age.sex <- replicate(3, MCMCglmm(formula(paste(x, " ~ age.class + sex + age.class:sex")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
  
  # null model
  m.null <- replicate(3, MCMCglmm(formula(paste(x, " ~ 1")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
  
  # put together the first models
  ms <- model.sel(m.age[[1]], m.age.sex[[1]], m.null[[1]], rank = "DIC")
  
  # rename rows so they match predictor names
  rownames(ms) <-  gsub("[[1]]", "",rownames(ms), fixed = TRUE)
  
  # save models in a list
  res <- list(model.tab = ms, m.age = m.age, m.age.sex = m.age.sex, m.null = m.null)
  
  return(res)
})

# add parameter name to models
names(mds.age.clss.sex.rsp) <- rsp.prms

```

```{r save mcmc results age categories and sex, eval=FALSE, echo=FALSE}

saveRDS(mds.age.clss.sex.rsp, "./suppl_mat/MCMCglmm models age classes and sex.RDS")

```

```{r run meanfreq sex model, eval = FALSE, echo = FALSE}

sub.sp.rsp.cll2 <- sub.sp.rsp.cll

sub.sp.rsp.cll2$sex <- as.numeric(as.factor(sub.sp.rsp.cll2$sex)) - 1.5
sub.sp.rsp.cll2$age.class <- factor(sub.sp.rsp.cll2$age.class, levels = c("non-volant", "volant", "adults"))
sub.sp.rsp.cll2$age.class <- as.numeric(as.factor(sub.sp.rsp.cll2$age.class)) - 2

freq.age.males <- replicate(3, MCMCglmm(mean_freq ~ age.class, random = ~ indiv, data =  sub.sp.rsp.cll[sub.sp.rsp.cll$sex == "M"  & sub.sp.rsp.cll$age.class != "non-volant" & which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)

freq.age.females <- replicate(3, MCMCglmm(mean_freq ~ age.class, random = ~ indiv, data =  sub.sp.rsp.cll[sub.sp.rsp.cll$sex == "F"  & sub.sp.rsp.cll$age.class != "non-volant" & which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)

summary(freq.age.males[[1]])

summary(freq.age.females[[1]])

summary(m2 <- MCMCglmm(mean_freq ~ age.class, random = ~ indiv, data =  sub.sp.rsp.cll[sub.sp.rsp.cll$age.class != "non-volant" & which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)))


m1 <- MCMCglmm(mean_freq ~ age.class + sex + age.class:sex, random = ~ indiv, data =  sub.sp.rsp.cll2[which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))

ma <- MCMCglmm(mean_freq ~ age.class + sex + age.class:sex, random = ~ indiv, data =  sub.sp.rsp.cll[sub.sp.rsp.cll$age.class != "non-volant" & which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
mb <- MCMCglmm(mean_freq ~ age.class:sex, random = ~ indiv, data =  sub.sp.rsp.cll[sub.sp.rsp.cll$age.class != "non-volant" & which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))

summary(m1)
summary(ma)
summary(mb)

m1.2 <- MCMCglmm(mean_freq ~ age.class, random = ~ indiv, data =  sub.sp.rsp.cll[ which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
summary(m1.2)


m2 <- MCMCglmm(mean_freq ~ age.class + sex + sex:age.class, random = ~ indiv, data =  sub.sp.rsp.cll[sub.sp.rsp.cll$age.class != "non-volant" & which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
summary(m2)


m3 <- MCMCglmm(mean_freq ~sex, random = ~ indiv + age.class, data =  sub.sp.rsp.cll[sub.sp.rsp.cll$age.class == "non-volant" & which(complete.cases(sub.sp.rsp.cll[, "mean_freq"])), ], verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE))
summary(m3)


```

Model selection results (only models that improved model fit compared to the null models are evaluated):

```{r mod sel print rsp classes and sex 1, eval = FALSE, echo = TRUE, results='asis'}

# put all model selection results in a list
mod.list <- lapply(1:length(mds.age.clss.sex.rsp), function(i)  data.frame(response = names(mds.age.clss.sex.rsp)[i], predictors = rownames(mds.age.clss.sex.rsp[[i]][[1]]), mds.age.clss.sex.rsp[[i]][[1]], stringsAsFactors = FALSE))

# make a data frame with all results
mod.sel.tab <- do.call(rbind, mod.list)

# fix predictor names
mod.sel.tab$predictors <- gsub("m.", "",  mod.sel.tab$predictors)

mod.sel.tab$predictors <- gsub("age.sex", "age + sex + age:sex",  mod.sel.tab$predictors)

mod.sel.tab
```

```{r mod sel print rsp classes and sex, eval = TRUE, echo = FALSE, results='asis'}

mds.age.clss.sex.rsp <- readRDS("./suppl_mat/MCMCglmm models age classes and sex.RDS")

# put all model selection results in a list
mod.list <- lapply(1:length(mds.age.clss.sex.rsp), function(i)  data.frame(response = names(mds.age.clss.sex.rsp)[i], predictors = rownames(mds.age.clss.sex.rsp[[i]][[1]]), mds.age.clss.sex.rsp[[i]][[1]], stringsAsFactors = FALSE))

# make a data frame with all results
mod.sel.tab <- do.call(rbind, mod.list)

# fix predictor names
mod.sel.tab$predictors <- gsub("m.", "",  mod.sel.tab$predictors)

mod.sel.tab$predictors <- gsub("age.sex", "age + sex + age:sex",  mod.sel.tab$predictors)

options(knitr.kable.NA = '')

df1 <- knitr::kable(mod.sel.tab[, c("response", "predictors", "df", "logLik", "DIC", "delta", "weight")], row.names = FALSE, escape = FALSE, format = "html")

df1 <- row_spec(df1, which(mod.sel.tab$delta== 0), background = adjustcolor(cols[9], alpha.f = 0.3))

kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

```

Select the best model for each parameter and extract effect sizes:
```{r Select the best model rsp age category and sex, eval = FALSE, echo = TRUE}

# select best models based on BIC
best.mods.rsp.age.clss.sex <- pblapply(mds.age.clss.sex.rsp, function(X){ 
  
  # if best model was at least 2 BIC units higher than null
  if (X[[1]]["m.null", "delta"] > 2) return(X[[rownames(X[[1]])[1]]][[1]]) else
      return(NA) # else if models were as good as null model return NA
  })

# rename
names(best.mods.rsp.age.clss.sex) <- rsp.prms

# remove the NA ones (the ones in which the null model was the best)
best.mods.rsp.age.clss.sex <- best.mods.rsp.age.clss.sex[sapply(best.mods.rsp.age.clss.sex, class) == "MCMCglmm"]
  
# extract fixed effect size
out <- lapply(1:length(best.mods.rsp.age.clss.sex), function(x){
  
  # fixed effects
  fe <- summary(best.mods.rsp.age.clss.sex[[x]])$solutions

  # Confidence intervals
  ci <- HPDinterval(best.mods.rsp.age.clss.sex[[x]]$Sol)
  
  # sample sizes  
  obs <- sub.sp.rsp.cll[complete.cases(sub.sp.rsp.cll[ , names(best.mods.rsp.age.clss.sex)[x]]), ]
  
  # put results together in a data frame
  res <-  data.frame(
    # response name
    response = names(best.mods.rsp.age.clss.sex)[x], 
    # predictors
    predictor = rownames(ci)[2:nrow(ci)], 
    # effect size
    effect_size = fe[-1, "post.mean"], 
    # Low confidence interval
    CI_2.5 = ci[2:nrow(ci), 1], 
    # High confidence interval
    CI_97.5 = ci[2:nrow(ci), 2], 
    # p value
    pMCMC  = fe[-1, "pMCMC"], 
    # number of individuals
    n.indv = length(unique(obs$indiv)),
    # number of non.volant
    n.non.volant = length(unique(obs$indiv[obs$age.class == "non-volant"])),
    # number of juveniles
    n.volant = length(unique(obs$indiv[obs$age.class == "volant"])), 
    # number of adults
    n.adults = length(unique(obs$indiv[obs$age.class == "adults"])), 
    # number of observations
    n.obs = nrow(obs), 
    # number of non-volant juvenies
    obs.non.volant = length(obs$indiv[obs$age.class == "non-volant"]),
    # number of volant juveniles
    obs.volant = length(obs$indiv[obs$age.class == "volant"]),
    # number of adults
    obs.adults = length(obs$indiv[obs$age.class == "adults"]),  
    stringsAsFactors = FALSE
    )
  
 return(res)
})

# put effect sizes in a single data frame 
es.rsp.age.clss.sex <- do.call(rbind, out)
rownames(es.rsp.age.clss.sex) <- 1:nrow(es.rsp.age.clss.sex)

# rename effects
es.rsp.age.clss.sex$predictor <- gsub("age.classnon-volant", "Non-volant_vs_adults", es.rsp.age.clss.sex$predictor)
es.rsp.age.clss.sex$predictor <- gsub("age.classvolant", "Volant_vs_adults", es.rsp.age.clss.sex$predictor)



```

```{r save models age category, eval = FALSE, echo = FALSE}

# save effect sizes
write.csv(es.rsp.age.clss.sex, "./suppl_mat/Effect sizes MCMCglmm models call age classes and sex.csv", row.names = FALSE)

saveRDS(best.mods.rsp.age.clss.sex, "./suppl_mat/best MCMCglmm models response age classes and sex.RDS")

```

```{r read es age category sex rsp, eval = TRUE, echo = FALSE}

es.rsp.age.clss.sex <- read.csv("./suppl_mat/Effect sizes MCMCglmm models call age classes and sex.csv", stringsAsFactors = FALSE)

```

```{r effect sizes age category, eval = TRUE, echo = FALSE}

md <- es.rsp.age.clss.sex

md$CI_2.5 <- round(md$CI_2.5, 4)
md$CI_97.5 <- round(md$CI_97.5, 4)

# get the ones that do not overlap with 0
mltp <- md$CI_2.5 * md$CI_97.5

md$CI_2.5 <- ifelse(mltp > 0, cell_spec(md$CI_2.5, "html", color ="white", background = cols[7], bold = T,  font_size = 12),  cell_spec(md$CI_2.5, "html"))

md$CI_97.5 <- ifelse(mltp > 0, cell_spec(md$CI_97.5, "html", color ="white", background = cols[7], bold = T,  font_size = 12),  cell_spec(md$CI_97.5, "html"))

df1 <- knitr::kable(md, row.names = FALSE, escape = FALSE, format = "html", digits = c(4))

df1 <- row_spec(df1, which(mltp > 0), background = adjustcolor(cols[9], alpha.f = 0.3))

kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

```

Non-volant and volant juveniles vs adults (graphs represent the difference with regard to the adult values):
```{r effect sizes adult vs non-volant & volant juveniles MCMC, eval = TRUE, echo = TRUE, fig.height = 4}

ggplot(es.rsp.age.clss.sex[es.rsp.age.clss.sex$predictor %in% c("Volant_vs_adults", "Non-volant_vs_adults"), ], aes(x = response, y = effect_size, col = predictor)) + 
  geom_point(size = 2.5, position = pos) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_errorbar(aes(ymin=CI_2.5, ymax=CI_97.5), width=.05, size = 1.2, position = pos) +
  scale_color_manual(values= cols[c(2, 7)]) +
  coord_flip()

```

Interaction between age and sex. Predictors in the following plot represent differences in response changes for males compare to females:

```{r effect sizes adult vs non-volant & volant juveniles sex MCMC, eval = TRUE, echo = TRUE, fig.height = 4}

ggplot(es.rsp.age.clss.sex[grepl(":sexM",es.rsp.age.clss.sex$predictor), ], aes(x = response, y = effect_size, col = predictor)) + 
  geom_point(size = 2.5, position = pos) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_errorbar(aes(ymin=CI_2.5, ymax=CI_97.5), width=.05, size = 1.2, position = pos) +
  scale_color_manual(values= cols[c(2, 7)]) +
  coord_flip()

```

Mean and violin plots for acoustic parameters:
(P ≤ 0.05 = &ast;&ast;; P ≤ 0.01 = &ast;&ast;&ast;; P ≤ 0.001 &ast;&ast;&ast;&ast;)
	
```{r Juveniles vs adults by age NOT USED, eval = FALSE, echo = FALSE, fig.height = 6, warning = FALSE}

# put data in long format for ggplot
rsh.sp.rsp.cll <- melt(sub.sp.rsp.cll[, c(unique(es.rsp.age.clss$response), "age.class")], id.vars=c("age.class"))

#remove not signf
rsh.sp.rsp.cll$age.class <- factor(rsh.sp.rsp.cll$age.class, levels = c("non-volant", "volant", "adults"))

#order variable levels
rsh.sp.rsp.cll$variable <- factor(rsh.sp.rsp.cll$variable, levels = unique(rsh.sp.rsp.cll$variable)[c(6, 3, 1, 2, 4, 5)])


# out2 <- rsh.sp.rsp.cll
# out2 <- out2[out2$variable %in% es.rsp.age.clss$response, ]

# set geom_line gpplot values for adding significance brakets and asterisks
es <- es.rsp.age.clss[es.rsp.age.clss$pMCMC < 0.05, ]
es$label <- "*"

names(es)[1] <- "variable"
es$x <- ifelse(es$predictor == "Non-volant_vs_adults", 2, 2.5)
es$sd <- sapply(es$variable, function(x) sd(rsh.sp.rsp.cll$value[rsh.sp.rsp.cll$variable == x], na.rm = TRUE))
es$max <- sapply(es$variable, function(x) max(rsh.sp.rsp.cll$value[rsh.sp.rsp.cll$variable == x], na.rm = TRUE))

# position of black asteriks if vs non-volants add sd*0.25 to max, if vs juvs 0.75
es$y <- ifelse(es$predictor != "Volant_vs_adults", es$max + (es$sd * 0.45), es$max + (es$sd * 1.3)) 

# line position in y axis
es$y2 <- es$y - es$sd * 0.08

# length of  vertical lines in brakets
es$y3 <- es$y2 - sapply(es$variable, function(x) dif.range(rsh.sp.rsp.cll$value[rsh.sp.rsp.cll$variable == x]) * 0.025)

#  y position of white asteriks
es$y4 <- es$y + es$sd * 0.5

# start and end of lines
es$x2 <- ifelse(es$x == 2, 1, 2)
es$x3 <- 3

# order levels
es$variable <- factor(es$variable, levels = levels(rsh.sp.rsp.cll$variable))

# create segment data for each comparison
data.segm <- lapply(1:nrow(es), function(x)
  data.frame(x = c(es$x2[x], es$x2[x], es$x3[x]), y = rep(es$y2[x], 3), xend = c(es$x3[x], es$x2[x], es$x3[x]), yend =  c(es$y2[x],es$y3[x], es$y3[x]), variable = es$variable[x]))

# get mean by variable and age category
mean.rsp.cll <- aggregate(value ~ variable + age.class, data= rsh.sp.rsp.cll, FUN = mean, na.rm = TRUE)

data.segm <- do.call(rbind, data.segm)

# create plot without significance brakets
ggplot(rsh.sp.rsp.cll, aes(age.class, value)) + 
      geom_violin(fill = cols.inf[10]) + 
      geom_point(size = 2.5,  color = cols.a1[8], data = mean.rsp.cll) +
    geom_text(col = "white", size = 9, data = es, mapping = aes(x = x, y = y4, label = label)) +
    geom_text(col = "black", size = 9, data = es, mapping = aes(x = x, y = y, label = label)) +
  facet_wrap(~ variable, scales = "free_y", ncol = 2, strip.position = "left", labeller = as_labeller(c(mean_freq = "Mean frequency (kHz)", skewness = "Skewness", num_syllables = "Number of syllables", syll_duration = "Syllable duration (ms)", syll_rate = "Syllable rate", PC1_consistency = "Consistency (PC1)"))) +
  theme(strip.background = element_blank(), strip.placement = "outside") +
   labs(y = NULL, x = "Age category") + 
  geom_segment(data=data.segm, lineend = "square", aes(x=x,y=y,yend=yend,xend=xend),inherit.aes=FALSE)


```

```{r Juveniles vs adults by age and sex, eval = TRUE, echo = TRUE, fig.height = 6, warning = FALSE}

# put data in long format for ggplot
rsh.sp.rsp.sex.cll <- melt(sub.sp.rsp.cll[, c(unique(es.rsp.age.clss.sex$response), "age.class", "sex")], id.vars=c("age.class", "sex"))

#remove not signf
rsh.sp.rsp.sex.cll$age.class <- factor(rsh.sp.rsp.sex.cll$age.class, levels = c("non-volant", "volant", "adults"))

sex.intr <- es.rsp.age.clss.sex$response[es.rsp.age.clss.sex$pMCMC < 0.05 & grepl("sexM", es.rsp.age.clss.sex$predictor)]

rsh.sp.rsp.sex.cll$sex[!rsh.sp.rsp.sex.cll$variable %in% sex.intr] <- "both"

#order variable levels
rsh.sp.rsp.sex.cll$variable <- factor(rsh.sp.rsp.sex.cll$variable, levels = unique(rsh.sp.rsp.sex.cll$variable)[c(6, 3, 1, 2, 4, 5)])

# set geom_line gpplot values for adding significance brakets and asterisks
es <- es.rsp.age.clss.sex[es.rsp.age.clss.sex$pMCMC < 0.05, ]
es$sex <- "both"
es$label <- "*"

names(es)[1] <- "variable"
es$x <- ifelse(es$predictor == "Non-volant_vs_adults", 2, 2.5)
es$sd <- sapply(es$variable, function(x) sd(rsh.sp.rsp.sex.cll$value[rsh.sp.rsp.sex.cll$variable == x], na.rm = TRUE))
es$max <- sapply(es$variable, function(x) max(rsh.sp.rsp.sex.cll$value[rsh.sp.rsp.sex.cll$variable == x], na.rm = TRUE))

# position of black asteriks if vs non-volants add sd*0.25 to max, if vs juvs 0.75
es$y <- ifelse(es$predictor != "Volant_vs_adults", es$max + (es$sd * 0.45), es$max + (es$sd * 1.3))

# fix for skewness
es$y[es$variable == "skewness"] <- 2.3 

# line position in y axis
es$y2 <- es$y - es$sd * 0.08

# length of  vertical lines in brakets
es$y3 <- es$y2 - sapply(es$variable, function(x) dif.range(rsh.sp.rsp.sex.cll$value[rsh.sp.rsp.sex.cll$variable == x]) * 0.025)

#  y position of white asteriks
es$y4 <- es$y + es$sd * 0.5

# start and end of lines
es$x2 <- ifelse(es$x == 2, 1, 2)
es$x3 <- 3

# order levels
es$variable <- factor(es$variable, levels = levels(rsh.sp.rsp.sex.cll$variable))

# create segment data for each comparison
data.segm <- lapply(1:nrow(es), function(x)
  data.frame(x = c(es$x2[x], es$x2[x], es$x3[x]), y = rep(es$y2[x], 3), xend = c(es$x3[x], es$x2[x], es$x3[x]), yend =  c(es$y2[x],es$y3[x], es$y3[x]), variable = es$variable[x]))

# get mean by variable and age category
mean.rsp.sex.cll <- aggregate(value ~ variable + age.class + sex, data= rsh.sp.rsp.sex.cll, FUN = mean, na.rm = TRUE)
 
data.segm <- do.call(rbind, data.segm)

#fix for interaction in mean freq
data.segm <- data.segm[-2, ]
data.segm$yend[2] <- data.segm$y[2] <- data.segm$yend[1] <- data.segm$y[1] <- data.segm$yend[3] * 0.98
data.segm$x[1] <- 1.75
data.segm$xend[1] <- 2.25
data.segm$x[2] <- 2.75
data.segm$xend[2] <- 3.25

rsh.sp.rsp.sex.cll$sex <- as.factor(rsh.sp.rsp.sex.cll$sex)

mean.rsp.sex.cll$sex <- as.factor(mean.rsp.sex.cll$sex)

# create plot without significance brakets
ggplot(rsh.sp.rsp.sex.cll, aes(x = age.class, y = value, fill = sex)) + 
      geom_violin() +
      geom_point(size = 2, data = mean.rsp.sex.cll, position = position_dodge(width = 0.9), col = "white") +
   scale_fill_manual(values = cols.a1[c(3, 5, 9)]) +
    geom_text(col = "white", size = 9, data = es, mapping = aes(x = x, y = y4, label = label)) +
    geom_text(col = "black", size = 9, data = es, mapping = aes(x = x, y = y, label = label)) +
  facet_wrap(~ variable, scales = "free_y", ncol = 2, strip.position = "left", labeller = as_labeller(c(mean_freq = "Mean frequency (kHz)", skewness = "Skewness", num_syllables = "Number of syllables", syll_duration = "Syllable duration (ms)", syll_rate = "Syllable rate", PC1_consistency = "Consistency (PC1)"))) +
  theme(strip.background = element_blank(), strip.placement = "outside") +
   labs(y = NULL, x = "Age category") + 
  geom_segment(data = data.segm, lineend = "square", aes(x = x, y = y, yend = yend, xend = xend), inherit.aes = FALSE)


```

---

### Call individuality

- Range of ages for juveniles between 1 and 70 days old split in 4 periods (after 70 days the sample size drops) 

- Adults included as a single category

- Same number of individuals per period (6, those with highest n) and same number of calls per individual (6 calls). This simplify the comparison of classification accuracy across segments

- Calls within individual were randomly sub-sampled and the process was iterated 100 times

- Mean and SD values are calculated from the 100 replicates

- Random Forest accuracy was measured with out-of-bag error in which each case is classified with a model that did not include that case for training

```{r ontogeny of individuality, eval = FALSE, echo = TRUE}

# rename age categories splitting in 4 breaks 
sp.rsp.cll$age.class[which(sp.rsp.cll$age < 70)] <- as.character(cut(sp.rsp.cll$age[which(sp.rsp.cll$age < 70)], breaks = 4))

# remove other juveniles
sp.rsp.cll <- sp.rsp.cll[sp.rsp.cll$age.class != "juveniles", ] 

# Set it as factor
sp.rsp.cll$age.class <- as.factor(sp.rsp.cll$age.class)

# ALL PARAMETERS (AP)
indv.prms <- c("syll_duration","mean_freq", "entropy", "modindx", "dfrange", "skewness", "num_syllables", "song.duration", "syll_rate", "gap.duration", "sd.gap.duration", "sd.elm.duration", grep("kurt.cc|mean.d|var.d1|median.c|min.cc|max.cc|skew.cc", names(sp.rsp.cll), value = TRUE))

# preprocess to scale and remove colinear parameters
pp.indv <- preProcess(sp.rsp.cll[, indv.prms], c("center", "scale", "corr"), cutoff = 0.7)

# save processed parameters
sp.rsp.cll.indv <- predict(pp.indv, sp.rsp.cll)

# remove not used parameters
sp.rsp.cll.indv <- sp.rsp.cll.indv[ , names(sp.rsp.cll.indv)  %in% c("indiv", "age.class", indv.prms)]

# split and prepare data by age category
dats <- lapply(unique(sp.rsp.cll.indv$age.class), function(x){
  
  # isolate data for that age category
  X <- sp.rsp.cll.indv[sp.rsp.cll.indv$age.class == x, ]

  # get only complete cases
  X <- X[complete.cases(X), ]

   # select 6 with highest sample size
  tab <- table(X$indiv)
  X <- X[X$indiv %in% names(tab)[order(-tab)][1:6], ]
  
  # add age category column 
  X$age.class <- x
  
  return(X)
})

# minimum sample size per individual
min.n <- min(sapply(dats, function(x) table(x$indiv)))

## run RF 100 times
class.res <- pbreplicate(reps, {out <- lapply(dats, function(X)
{  

  # selec min.n samples per individual
  X <- X[rownames(X) %in% unlist(tapply(rownames(X), X$indiv, sample, min.n)), ]
  
  # save age category for output data frame
  age.class <- X$age.class[1]
  
  # remove age category column
  X$age.class <- NULL
  
  # run random forest
  rf <- ranger(indiv ~ ., data = X, num.trees = 10000, importance = "impurity")
  rf.error <- rf$prediction.error
  
  
return(data.frame(age.class, sample.size = nrow(X), individuals = length(unique(X$indiv)), oob.error = rf.error, most.imp.vars = paste(names(sort(rf$variable.importance, decreasing = TRUE))[1:5], collapse = "|")))
})

do.call(rbind, out)

}, simplify = FALSE)

class.res <- do.call(rbind, class.res)

class.agg <- aggregate(oob.error ~ age.class + sample.size + individuals, data = class.res, mean)

class.agg$sd <- aggregate(oob.error ~ age.class + sample.size + individuals, data = class.res, sd)$oob.error

```

```{r save results class indiv, eval = FALSE, echo = FALSE}

write.csv(class.agg, "./suppl_mat/Classification accuracy by ontogenetic period.csv", row.names = FALSE)

write.csv(class.res, "./suppl_mat/Complete data classification accuracy by ontogenetic period.csv", row.names = FALSE)

```

```{r read results class indiv , eval = TRUE, echo = FALSE}

class.agg <- read.csv("./suppl_mat/Classification accuracy by ontogenetic period.csv", stringsAsFactors = FALSE)

class.res <- read.csv("./suppl_mat/Complete data classification accuracy by ontogenetic period.csv", stringsAsFactors = FALSE)

```

```{r ontogeny of individuality plots, eval = TRUE, echo = TRUE, fig.height = 4}

# orger age category levels
class.agg$age.class <- factor(class.agg$age.class, levels = unique(class.agg$age.class)[c(3, 1, 2, 4, 5)])

# make them numeric
class.agg$num.age.class <- as.numeric(class.agg$age.class) - 3

gg.indv.rsp <- ggplot(class.agg, aes(x = num.age.class, y = 1 - oob.error)) +
  geom_point(size = 2.5, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_errorbar(aes(ymin = 1- oob.error - sd, ymax = 1- oob.error + sd), width=.1, size = 1.2, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_hline(yintercept = 1- 5/6, lty = 3) +
  # annotate("text", x = 3, y = 0.2,  label = "Expected by chance") +
  labs(x = "Age Category (days)", y = "Individuality (1-OOB error)") +
  scale_x_continuous(limits = c(-2.2, 2.2), labels= levels(class.agg$age.class))

gg.indv.rsp

```

#### Sample sizes

```{r, eval = FALSE}

class.agg

```

```{r, eval = TRUE, echo = FALSE}

kbl <- kable(class.agg[, 1:4], align = "c", row.names = F,  format = "html")

kbl <-  kable_styling(kbl, bootstrap_options = "striped", font_size = 14)

kbl
```

Get the proportion of MFCCs that were among the 5 most important variables across all random forest models:

```{r var imp random forest, eval = TRUE, echo = TRUE}

sum(grepl("cc",unlist(strsplit(as.character(class.res$most.imp.vars), "|", fixed = TRUE)))) / (nrow(class.res) * 5)

```



#### Evaluate models of individuality ontogenetic change

To determine the pattern of ontogenetic change in individuality we compare a linear model representing no change in individuality through time to a quadratic model which represents a decrease in individuality in intermidiate age categories:  

```{r quadratic model 1, eval = TRUE, echo = FALSE}

# order age factor 
class.res$age.class <- factor(class.res$age.class, levels = unique(class.res$age.class)[c(3, 1, 2, 4, 5)])

# convert to numeric
class.res$num.age.class <- as.numeric(class.res$age.class)

# scale, mean = 0
class.res$num.age.class <- c(scale(class.res$num.age.class, scale = FALSE))

### evaluate models
# quadratic
quad.md <- lm((1 - oob.error) ~ poly(num.age.class, 2), data = class.res)

# null model
nll.md <- lm((1 - oob.error) ~ 1, data = class.res)

```

```{r quadratic model 2, eval = FALSE, echo = TRUE}

# order age factor 
class.res$age.class <- factor(class.res$age.class, levels = unique(class.res$age.class)[c(3, 1, 2, 4, 5)])

# convert to numeric
class.res$num.age.class <- as.numeric(class.res$age.class)

# scale, mean = 0
class.res$num.age.class <- c(scale(class.res$num.age.class))

### evaluate models
# quadratic
quad.md <- lm((1 - oob.error) ~ poly(num.age.class, 2), data = class.res)

# null model
nll.md <- lm((1 - class.res$oob.error) ~ 1)

# compare AIC
AIC(quad.md, nll.md)

# evalute best model
data.frame(effect_size = coef(quad.md), confint(quad.md), row.names = c("intercept", "age.class", "(age.class)^2"))

```

```{r quadratic model 3, eval = TRUE, echo = FALSE}

# compare AIC
AIC(quad.md, nll.md)

# evalute best model
df <- data.frame(effect_size = coef(quad.md), confint(quad.md), row.names = c("intercept", "age.class", "(age.class)^2"))

names(df)[2:3] <- c("lowerCI", "upperCI")

kbl <- kable(df, align = "c", row.names = TRUE,  format = "html")

kbl <-  kable_styling(kbl, bootstrap_options = "striped", font_size = 14)

kbl


```

Plot previous graph with best fit line:

```{r ontogeny of individuality plots 2, eval = TRUE, echo = TRUE, fig.height = 4}

# create function to predict individuality for ggplot
prd <- function(x) predict(quad.md, newdata = data.frame(num.age.class = x))

# orger age category levels
class.agg$age.class <- factor(class.agg$age.class, levels = unique(class.agg$age.class)[c(3, 1, 2, 4, 5)])

# make them numeric
class.agg$num.age.class <- as.numeric(class.agg$age.class) - 3

gg.indv.rsp <- ggplot(class.agg, aes(x = num.age.class, y = 1 - oob.error)) +
  stat_function(fun = prd, xlim = c(-2, 2), col = cols[5], size = 0.6) +
  geom_point(size = 2.5, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_errorbar(aes(ymin = 1- oob.error - sd, ymax = 1- oob.error + sd), width=.1, size = 1.2, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_hline(yintercept = 1- 5/6, lty = 3) +
  # annotate("text", x = 3, y = 0.2,  label = "Expected by chance") +
  labs(x = "Age Category", y = "Individuality (1-OOB error)") +
  scale_x_continuous(limits = c(-2.2, 2.2), labels= levels(class.agg$age.class))

gg.indv.rsp

```

```{r ontogeny of sex diffs, eval = FALSE, echo = FALSE}
## Ontogeny of sex differences in response calls

# - Range of ages for juveniles between 1 and 70 days old split in 4 periods (after 70 days the sample size drops) 
# 
# - Adults included as a single category
# 
# - Same number of individuals per period (6, those with highest n) and same number of calls per individual (6 calls). This simplify the comparison of classification accuracy across segments
# 
# - Calls within individual were randomly sub-sampled and the process was iterated 100 times
# 
# - Mean and SD values are calculated from the 100 replicates
# 
# - Random Forest accuracy was measured with out-of-bag error in which each case is classified with a model that did not include that case for training


# save processed parameters
sp.rsp.cll.indv <- predict(pp.indv, sp.rsp.cll)

# remove not used parameters
sp.rsp.cll.indv <- sp.rsp.cll.indv[ , names(sp.rsp.cll.indv)  %in% c("sex", "age.class", "indiv", indv.prms)]

# split and prepare data by age category
dats <- lapply(unique(sp.rsp.cll.indv$age.class), function(x){
  
  # isolate data for that age category
  X <- sp.rsp.cll.indv[sp.rsp.cll.indv$age.class == x, ]

  # get only complete cases
  X <- X[complete.cases(X), ]

   # select 6 with highest sample size
  tab <- table(X$sex)
  X <- X[X$sex %in% names(tab)[order(-tab)][1:6], ]
  
  # add age category column 
  X$age.class <- x
  
  return(X)
})

# minimum sample size per individual
min.n <- min(sapply(dats, function(x) table(x$sex)))

## run RF 100 times
class.res <- replicate(reps, {out <- lapply(dats, function(X)
{  

  # selec min.n samples per sex
  X <- X[rownames(X) %in% unlist(tapply(rownames(X), X$sex, sample, min.n)), ]
  
  # save age category for output data frame
  age.class <- X$age.class[1]
  
  # remove age category column
  X$age.class <- NULL
  
  # save n indiv for output data frame
  n.indiv <- length(unique(X$indiv))
  n.males <- length(unique(X$indiv[X$sex == "M"]))
  n.females <- length(unique(X$indiv[X$sex == "F"]))
  
  # remove age category column
  X$indiv <- NULL
  
  # run random forest
  rf <- ranger(sex ~ ., data = X, num.trees = 10000, importance = "impurity")
  rf.error <- rf$prediction.error
  
  return(data.frame(age.class, sample.size = nrow(X), method = "RandomForest",  oob.error = rf.error, n.indiv, n.males, n.females))
})

do.call(rbind, out)

}, simplify = FALSE)

class.res <- do.call(rbind, class.res)

class.agg.sex <- aggregate(cbind(oob.error, n.indiv, n.males, n.females) ~ age.class + sample.size, data = class.res, mean)

class.agg.sex$sd.error <- aggregate(oob.error ~ age.class + sample.size, data = class.res, sd)$oob.error

class.agg.sex$sd.n.indiv <- aggregate(n.indiv ~ age.class + sample.size, data = class.res, sd)$n.indiv

class.agg.sex$sd.n.males <- aggregate(n.males ~ age.class + sample.size, data = class.res, sd)$n.males

class.agg.sex$sd.n.females <- aggregate(n.females ~ age.class + sample.size, data = class.res, sd)$n.females

```

```{r save results class sex, eval = FALSE, echo = FALSE}

write.csv(class.agg.sex, "./suppl_mat/Classification accuracy by ontogenetic period sex.csv", row.names = FALSE)

```

```{r read results class sex , eval = FALSE, echo = FALSE}

class.agg.sex <- read.csv("./suppl_mat/Classification accuracy by ontogenetic period sex.csv", stringsAsFactors = FALSE)

```

```{r ontogeny of group signatures, eval = FALSE, echo = FALSE}

# rename age categories splitting in 4 breaks 
sp.rsp.cll$age.class[which(sp.rsp.cll$age < 70)] <- as.character(cut(sp.rsp.cll$age[which(sp.rsp.cll$age < 70)], breaks = 4))

# remove other juveniles
sp.rsp.cll <- sp.rsp.cll[sp.rsp.cll$age.class != "juveniles", ] 

# Set it as factor
sp.rsp.cll$age.class <- as.factor(sp.rsp.cll$age.class)

# ALL PARAMETERS (AP)
indv.prms <- c("syll_duration","mean_freq", "entropy", "modindx", "dfrange", "skewness", "num_syllables", "song.duration", "syll_rate", "gap.duration", "sd.gap.duration", "sd.elm.duration", grep("kurt.cc|mean.d|var.d1|median.c|min.cc|max.cc|skew.cc", names(sp.rsp.cll), value = TRUE))

# preprocess to scale and remove colinear parameters
pp.grp <- preProcess(sp.rsp.cll[, indv.prms], c("center", "scale", "corr"), cutoff = 0.7)

# save processed parameters
sp.rsp.cll.grp <- predict(pp.grp, sp.rsp.cll)

# remove not used parameters
sp.rsp.cll.grp <- sp.rsp.cll.grp[ , names(sp.rsp.cll.grp)  %in% c("indiv", "group", "age.class", indv.prms)]

# split and prepare data by age category
dats <- lapply(unique(sp.rsp.cll.indv$age.class), function(x){
  
  # isolate data for that age category
  X <- sp.rsp.cll.grp[sp.rsp.cll.grp$age.class == x, ]

  # get only complete cases
  X <- X[complete.cases(X), ]

   # select 6 with highest sample size
  tab <- table(X$indiv, X$group)
  
  X <- X[X$group %in% names(which(apply(tab, 2, function(x) length(x[x != 0])) > 1)), ]

  tab <- table(X$indiv)
  
  
  # add age category column 
  X$age.class <- x
  
  return(X)
})

# minimum sample size per individual
sapply(dats, function(x) table(x$group[!duplicated(x$indiv)]))

# remove third age category
dats <- dats[-3]

## use 2 individuals from 2 groups each time

## run RF 100 times
class.res <- replicate(10, {out <- lapply(dats, function(X)
{  
  grp.smp <- sample(unique(X$group), 2)
  
  ind.smp <- c(sample(unique(X$indiv[X$group == grp.smp[1]]), 2), sample(unique(X$indiv[X$group == grp.smp[2]]), 2))
  
  # selec 2 samples per individual
  X <- X[X$indiv %in% ind.smp, ]
  
  # selec max of 10 samples per individual
  X <- X[unlist(sapply(ind.smp, function(x) {
    if (sum(X$indiv == x) > 10)
    return(sample(which(X$indiv == x), 10)) else 
      return(which(X$indiv == x)) 
    }), use.names = FALSE), ]

  # save age category for output data frame
  age.class <- X$age.class[1]
  
  # remove age category column
  X$indiv <- X$age.class <- NULL
  
  X$group <- as.factor(X$group)
  
  # run random forest
  rf <- ranger(group ~ ., data = X, num.trees = 10000, importance = "impurity")
  rf.error <- rf$prediction.error

return(data.frame(age.class, sample.size = nrow(X), method = "RandomForest",  oob.error = rf.error))
})

do.call(rbind, out)

}, simplify = FALSE)

class.res <- do.call(rbind, class.res)

class.agg <- aggregate(oob.error ~ age.class , data = class.res, mean)

class.agg$sd <- aggregate(oob.error ~ age.class , data = class.res, sd)$oob.error

ggplot(class.agg, aes(x = age.class, y = 1 - oob.error)) +
  # stat_function(fun = prd, xlim = c(-2, 2), col = cols[5], size = 1.3, linetype = "dotted") +
  geom_point(size = 2.5, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_errorbar(aes(ymin = 1- oob.error - sd, ymax = 1- oob.error + sd), width=.1, size = 1.2, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_hline(yintercept = 1/2, lty = 3) +
  # annotate("text", x = 3, y = 0.2,  label = "Expected by chance") +
  labs(x = "Age Category", y = "Group classification (1-OOB error)") 
  # scale_x_continuous(limits = c(-2.2, 2.2), labels= levels(class.agg$age.class))


```

```{r ontogeny of sex differentiation plots, eval = FALSE, echo = FALSE, fig.height = 4}

class.agg.sex$age.class <- factor(class.agg.sex$age.class, levels = unique(class.agg.sex$age.class)[c(3, 1, 2, 4, 5)])

ggplot(class.agg.sex, aes(x = age.class, y = 1- oob.error)) + 
  geom_point(size = 2.5, col = cols[7], alpha = 1) +
  geom_errorbar(aes(ymin = 1- oob.error - sd.error, ymax = 1- oob.error + sd.error), width=.05, size = 1.2, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_hline(yintercept = 0.5, lty = 3) +
  annotate("text", x = 3, y = 0.52,  label = "Expected by chance") +
  labs(x = "Age category", y = "Individuality (1-OOB error)")

```

```{r put individuality plots together, eval = FALSE, echo = FALSE}

gg2 <- gg.indv.rsp + theme(axis.title.y=element_blank(), axis.title.x = element_blank())
gg1 <- gg.indv.inq + theme(axis.title.y = element_blank())

plot <- plot_grid(gg2, gg1, align='vh', vjust= 2, scale = 1, nrow = 2,  labels = c("A", "B"), hjust = -4) 
#create common x and y labels

y.grob <- grid::textGrob("     Individuality (1 - out-of-bag error)", 
                   gp=grid::gpar(fontsize = 15), rot=90)

#add to plot
gridExtra::grid.arrange(gridExtra::arrangeGrob(plot, left = y.grob))

```

```{r, eval = FALSE, echo = FALSE}
### Sample sizes
class.agg.sex
```

```{r, eval = FALSE, echo = FALSE}

kbl <- kable(class.agg.sex[, c(1:3, 7, 4, 8, 5, 9, 6, 10)], align = "c", row.names = F,  format = "html")

kbl <-  kable_styling(kbl, bootstrap_options = "striped", font_size = 14)

kbl
```

## Inquiry call ontogeny
### Adults vs juveniles

Bayesian MCMC generalized linear models on response call acoustic parameters with individual as a random effect and age category or sex as predictors. 3 models compared for each acoustic parameter: 

1. only age as predictor:
$$Acoustic\ parameter \sim age.class + (1 | indiv)$$
2. age, sex and their interaction as predictors: 
$$Acoustic\ parameter \sim age.class + sex + age.class:sex + (1 | indiv)$$
3. Null model with no predictor:
$$Acoustic\ parameter \sim 1 + (1 | indiv)$$

A loop is used to run these 3 models for each selected acoustic parameters. Each model is replicated 3 times with starting values sampled from a Z-distribution ("start" argument in MCMCglmm()). Parameters are scaled (i.e. z-transformed) to obtained standardized effect sizes (within the loop). Diagnostic plots for MCMC model performance are shown at the end of this report:

```{r adults vs juveniles inquiry stats MCMCglmm, eval = FALSE, echo = TRUE,  fig.height=10}

# Selecting between with and without interaction
mods.inq.age.class <- pblapply(inq.prms, function(x){

   # choose complete cases and data for juveniles
  X <- sp.inq[complete.cases(sp.inq[ , x]), ]
  
  # scale and center
  X[, x] <- scale(X[, x])
  
  # age and sex 
  m.age.sex <- replicate(3, MCMCglmm(formula(paste(x, " ~ age.class + sex + age.class:sex")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
  
  m.age <- replicate(3, MCMCglmm(formula(paste(x, " ~ age.class")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
  
  m.null <- replicate(3, MCMCglmm(formula(paste(x, " ~ 1")), random = ~ indiv, data = X, verbose = FALSE, nitt = itrns,  start = list(QUASI = FALSE)), simplify = FALSE)
  
  # put together models
  ms <- model.sel(m.age.sex[[1]], m.age[[1]], m.null[[1]], rank = "DIC")

  
  # rename rows so they match predictor names
  rownames(ms) <-  gsub("[[1]]", "",rownames(ms), fixed = TRUE)
  
  # put results in a list
  res <- list(model.tab = ms, m.age.sex = m.age.sex, m.age = m.age, m.null = m.null)

  return(res)
  })

names(mods.inq.age.class) <- inq.prms

```

Select the best model for each parameter and extract effect sizes:
```{r select models inq, eval = FALSE, echo = TRUE}

# get best model
best.mods.inq.age.class <- pblapply(mods.inq.age.class, function(X){ 
  
  # if best model was at least 2 BIC units higher than null
  if (X[[1]]["m.null", "delta"] > 2) 
    return(X[[rownames(X[[1]])[1]]][[1]]) else
      return(NA)
  })

# names list objects
names(best.mods.inq.age.class) <- names(mods.inq.age.class)

# remove NAs
best.mods.inq.age.class <- best.mods.inq.age.class[sapply(best.mods.inq.age.class, class) == "MCMCglmm"]
  
# fixed effect size
out <- lapply(1:length(best.mods.inq.age.class), function(x){
  
  # fixed effects
  fe <- summary(best.mods.inq.age.class[[x]])$solutions

  # confidence intervals 
  ci <- HPDinterval(best.mods.inq.age.class[[x]]$Sol)
  
  # sample sizes  
  obs <- sp.inq[complete.cases(sp.inq[ , names(best.mods.inq.age.class)[x]]), ]
  
  # put together results 
  res <-  data.frame(
    # response name
    response = names(best.mods.inq.age.class)[x], 
    # predictor name
    predictor = rownames(ci)[2:nrow(ci)], 
    #effect size
    effect_size = fe[-1, "post.mean"], 
    # low confidence interval
    CI_2.5 = ci[2:nrow(ci), 1], 
    # low confidence interval
    CI_97.5 = ci[2:nrow(ci), 2], 
    # p value
    pMCMC = fe[-1, "pMCMC"], 
    # number of individuals
    n.indv = length(unique(obs$indiv)),
    # number of juveniles
    n.juvs = length(unique(obs$indiv[obs$age.class == "juveniles"])), 
    # number of adults
    n.adults = length(unique(obs$indiv[obs$age.class == "adults"])), 
    # number of observations
    n.obs = nrow(obs), 
    # number of juveniles
    obs.juvs = length(obs$indiv[obs$age.class == "juveniles"]), 
    # number of adults
    obs.adults = length(obs$indiv[obs$age.class == "adults"]),  
    stringsAsFactors = FALSE
    )
  
 return(res)
})

# put all results together
es.inq.age.class <- do.call(rbind, out)

# rename rows
rownames(es.inq.age.class) <- 1:nrow(es.inq.age.class)
```

```{r save inq models results, eval = FALSE, echo = FALSE}

saveRDS(mods.inq.age.class, "./suppl_mat/MCMCglmm models juvs vs adults inquiry.RDS")

saveRDS(best.mods.inq.age.class, "./suppl_mat/best MCMCglmm models juvs vs adults inquiry.RDS")

write.csv(es.inq.age.class, "./suppl_mat/Effect sizes MCMCglmm models juvs vs adults inquiry.csv", row.names = FALSE)

```

```{r print best models 1, eval = FALSE, echo = TRUE, results='asis'}

# put all model selection results in a list
mod.list <- lapply(1:length(mods.inq.age.class), function(i)  data.frame(response = names(mods.inq.age.class)[i], predictors = rownames(mods.inq.age.class[[i]][[1]]), mods.inq.age.class[[i]][[1]], stringsAsFactors = FALSE))

# make a data frame with all results
mod.sel.tab <- do.call(rbind, mod.list)

# fix predictor names
mod.sel.tab$predictors <- gsub("m.", "",  mod.sel.tab$predictors)

mod.sel.tab$predictors <- gsub("age.sex", "age + sex + age:sex",  mod.sel.tab$predictors)

mod.sel.tab
```

```{r print best models 2, eval = TRUE, echo = FALSE, results='asis'}

mods.inq.age.class <- readRDS("./suppl_mat/MCMCglmm models juvs vs adults inquiry.RDS")

# put all model selection results in a list
mod.list <- lapply(1:length(mods.inq.age.class), function(i)  data.frame(response = names(mods.inq.age.class)[i], predictors = rownames(mods.inq.age.class[[i]][[1]]), mods.inq.age.class[[i]][[1]], stringsAsFactors = FALSE))

# make a data frame with all results
mod.sel.tab <- do.call(rbind, mod.list)

# fix predictor names
mod.sel.tab$predictors <- gsub("m.", "",  mod.sel.tab$predictors)

mod.sel.tab$predictors <- gsub("age.sex", "age + sex + age:sex",  mod.sel.tab$predictors)

options(knitr.kable.NA = '')

df1 <- knitr::kable(mod.sel.tab[, c("response", "predictors", "df", "logLik", "DIC", "delta", "weight")], row.names = FALSE, escape = FALSE, format = "html")

df1 <- row_spec(df1, which(mod.sel.tab$delta== 0), background = adjustcolor(cols[9], alpha.f = 0.3))
  
kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

```

Inquiry call parameters of juveniles vs adults (graphs represent the difference with regard to the adult values):
```{r effect sizes adult vs juveniles MCMC inquiry, eval = FALSE, echo = TRUE, fig.height = 4}

ggplot(es.inq.age.class[es.inq.age.class$predictor == "age.classjuveniles",], aes(x = response, y = effect_size)) + 
  geom_point(size = 2.5, position = pos, color = cols[8]) +
    geom_hline(yintercept = 0, lty = 2) +
  geom_errorbar(aes(ymin=CI_2.5, ymax=CI_97.5), width=.05, size = 1.2, position = pos, color = cols[8]) +
  coord_flip()

```

```{r effect sizes adult vs juveniles MCMC inquiry 2, eval = TRUE, echo = FALSE,  fig.height = 4}

es.inq.age.class <- read.csv("./suppl_mat/Effect sizes MCMCglmm models juvs vs adults inquiry.csv", stringsAsFactors = FALSE)

ggplot(es.inq.age.class[es.inq.age.class$predictor == "age.classjuveniles",], aes(x = response, y = effect_size)) + 
  geom_point(size = 2.5, position = pos, color = cols[8]) +
    geom_hline(yintercept = 0, lty = 2) +
  geom_errorbar(aes(ymin=CI_2.5, ymax=CI_97.5), width=.05, size = 1.2, position = pos, color = cols[8]) +
  coord_flip()

```

```{r effect sizes adult vs juveniles MCMC inquiry 3, eval = FALSE, echo = TRUE}

md <- es.inq.age.class[, !grepl("mean|sd", names(es.inq.age.class))]

md$CI_2.5 <- round(md$CI_2.5, 4)
md$CI_97.5 <- round(md$CI_97.5, 4)

# get the ones that do not overlap with 0
mltp <- md$CI_2.5 * md$CI_97.5

md$CI_2.5 <- ifelse(mltp > 0, cell_spec(md$CI_2.5, "html", color ="white", background = cols[7], bold = T,  font_size = 12),  cell_spec(md$CI_2.5, "html"))

md$CI_97.5 <- ifelse(mltp > 0, cell_spec(md$CI_97.5, "html", color ="white", background = cols[7], bold = T,  font_size = 12),  cell_spec(md$CI_97.5, "html"))

md

```

```{r effect sizes adult vs juveniles MCMC inquiry 4, eval = TRUE, echo = FALSE}

md <- es.inq.age.class[, !grepl("mean|sd", names(es.inq.age.class))]

md$CI_2.5 <- round(md$CI_2.5, 4)
md$CI_97.5 <- round(md$CI_97.5, 4)

# get the ones that do not overlap with 0
mltp <- md$CI_2.5 * md$CI_97.5

md$CI_2.5 <- ifelse(mltp > 0, cell_spec(md$CI_2.5, "html", color ="white", background = cols[7], bold = T,  font_size = 12),  cell_spec(md$CI_2.5, "html"))

md$CI_97.5 <- ifelse(mltp > 0, cell_spec(md$CI_97.5, "html", color ="white", background = cols[7], bold = T,  font_size = 12),  cell_spec(md$CI_97.5, "html"))

df1 <- knitr::kable(md, row.names = FALSE, escape = FALSE, format = "html", digits = c(4))

df1 <- row_spec(df1, which(mltp > 0), background = adjustcolor(cols[9], alpha.f = 0.3))

kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 12)

```

Mean and violin plots for acoustic parameters:
```{r Juveniles vs adults by age and sex inquiry, eval = TRUE, echo = TRUE, fig.height = 6}

# convert to ms
sp.inq$call_duration <- sp.inq$call_duration * 1000

# long format
l.sp.inq <- melt(sp.inq[, c(inq.prms, "sex", "age.class")], id.vars=c("sex", "age.class"))

#order variable levels
l.sp.inq$variable <- factor(l.sp.inq$variable, levels = unique(l.sp.inq$variable)[c(1, 3, 4, 6, 2, 5)])

es <- es.inq.age.class
es <- es[es$pMCMC < 0.05, ]
es$label <- "*"

# es$label <- ifelse(es$pMCMC < 0.001, "***", ifelse(es$pMCMC < 0.01, "**", "*"))

names(es)[1] <- "variable"

# set mid point for brakets
es$x <- 1.5

#get SD and max of value for each parameter
es$sd <- sapply(es$variable, function(x) sd(l.sp.inq$value[l.sp.inq$variable == x]))
es$max <- sapply(es$variable, function(x) max(l.sp.inq$value[l.sp.inq$variable == x]))

# position of black asteriks if vs non-volants add sd*0.25 to max, if vs juvs 0.75
es$y <- es$max + (es$sd * 0.45) 

# line position in y axis
es$y2 <- es$y - es$sd * 0.08

# length of  vertical lines in brakets
es$y3 <- es$y2 - sapply(es$variable, function(x) dif.range(l.sp.inq$value[l.sp.inq$variable == x]) * 0.025)

#  y position of white asteriks
es$y4 <- es$y + es$sd * 0.5

# start and end of  braket lines
es$x2 <- 1
es$x3 <- 2


# create segment data for each comparison
data.segm <- lapply(1:nrow(es), function(x)
  data.frame(x = c(es$x2[x], es$x2[x], es$x3[x]), y = rep(es$y2[x], 3), xend = c(es$x3[x], es$x2[x], es$x3[x]), yend =  c(es$y2[x],es$y3[x], es$y3[x]), variable = es$variable[x]))

agg.inq.prms <- aggregate(value ~ variable + age.class, data = l.sp.inq, mean)


data.segm <- do.call(rbind, data.segm)

# set level order for age categories
l.sp.inq$age.class <- factor(l.sp.inq$age.class, levels = c("juveniles", "adults"))


ggplot(l.sp.inq, aes(age.class, value)) + 
    geom_violin(fill = cols.a1[3]) +
    geom_point(size = 2.5,  color = "white", data = agg.inq.prms) +
    geom_text(col = "white", size = 9, data = es, mapping = aes(x = x, y = y4, label = label)) +
    geom_text(col = "black", size = 9, data = es, mapping = aes(x = x, y = y, label = label)) +
   facet_wrap(~ variable, scales = "free_y", ncol = 2, strip.position = "left", labeller = as_labeller(c(entropy = "Entropy", freq_slope = "Frequency slope (kHz/s)", freq_range = "Frequency range (kHz)", call_duration = "Call duration (ms)", mean_freq = "Mean frequency (kHz)", modulation_index = "Modulation index"))) +
     theme(strip.background = element_blank(), strip.placement = "outside") + 
  labs(y = NULL, x = "Age category") + 
  geom_segment(data=data.segm, lineend = "square", aes(x=x,y=y,yend=yend,xend=xend),inherit.aes=FALSE) # addd brakets and asteriks


```

## Call individuality 

- Juveniles did not have enough samples so we used same number of individuals in both age categories (5) and same number of calls per individual as in juveniles (2, 2, 10, 10 and 10 calls)

- Calls within individual with more than 2 calls were randomly sub-sampled and the process was iterated 100 times

- Mean and SD values are calculated from the 100 replicates

- Random Forest accuracy was measured with cross-validation (out-of-bag error) in which each case is classified with a model that did not include that case for training

```{r ontogeny of individuality inquiry, eval = FALSE, echo = TRUE}

# parameters to be used
indv.inq.prms <- c("call_duration", "mean_freq", "sd", "freq.median", "freq.Q25", "freq.Q75", "freq.IQR", "time.median", "time.Q25", "time.Q75", "time.IQR", "skew", "kurt", "sp.ent", "time.ent", "entropy", "sfm", "meandom", "mindom", "maxdom", "freq_slope", "freq_range", "startdom", "enddom", "modulation_index", "peakf", grep("kurt.cc|mean.d|var.d1|median.c|min.cc|max.cc|skew.cc", names(sp.inq), value = TRUE))

pp <- preProcess(sp.inq[, indv.inq.prms], method = c("scale", "center"))

sp.inq.indv <- predict(pp, sp.inq)

# remove not used parameters
sp.inq.indv <- sp.inq.indv[ , c("indiv", "age.class", indv.inq.prms)]

#####  on all original acoustic parameters #######
dats.indv <- lapply(na.omit(unique(sp.inq.indv$age.class)), function(x){
 
   X <- sp.inq.indv[which(sp.inq.indv$age.class == x), ]

  X <- X[complete.cases(X), ]

   # select 6 with highest sample size
  tab <- table(X$indiv)
  X <- X[X$indiv %in% names(tab)[order(-tab)][1:6], ]
  
  X$age.class <- x
  
  return(X)
})


# minimum sample size per individual
# sapply(dats.indv, function(x) (table(x$indiv)))

# number of juveniles
table(dats.indv[[2]]$indiv)

# minimum number of samples for 5 individuals
min.ns <- c(2, 2, 10, 10, 10)

#  replicate 100 times and calculate classification error
inq.classf <- replicate(reps, {
  out <- lapply(dats.indv, function(X)
{  
  # split by individual
  Y <- split(X, f = X$indiv)
  
  if (X$age.class[1] == "juveniles")
    # select sample sizes
    Z <- lapply(Y, function(x){
      
      if (nrow(x) == 2) return(x) else
        return(x[sample(1:nrow(x), 10), ])
    }) else 
      {
      
      Y<- Y[sample(1:length(Y), 5)]
      
      Z <- lapply(1:length(Y), function(y){
        W <- Y[[y]]
        
        W <- W[sample(1:nrow(W), min.ns[y]), ]
      })
    }
      
  W <- do.call(rbind, Z)  

  # remove age category
  age.class <- X$age.class[1]
  W$age.class <- NULL
  
  # run random forest
  rf <- ranger(indiv ~ ., data = W, num.trees = 10000, importance = "impurity")
  rf.error <- rf$prediction.error
  
  
return(data.frame(age.class, sample.size = nrow(W), individuals = length(unique(W$indiv)), method = "RandomForest",  oob.error = rf.error))
})

do.call(rbind, out)

}, simplify = FALSE)
    
inq.classf <- do.call(rbind, inq.classf)

#aggregate mean and sd results
agg.inq.classf <- aggregate(oob.error ~ age.class + sample.size + individuals, data = inq.classf, mean)

agg.inq.classf$sd <- aggregate(oob.error ~ age.class + sample.size + individuals, data = inq.classf, sd)$oob.error

```

```{r save class results, eval = FALSE, echo = FALSE}

write.csv(agg.inq.classf, "./suppl_mat/Classification accuracy by age class INQUIRY.csv", row.names = FALSE)

# calculate error expected by chance
# min.n <- c(2, 2, 10, 10, 10)
# min.n <- c(31, 31)
# # min.n <- rep(6, 6)
# 
# id <- unlist(sapply(1:length(min.n), function(x) rep(x, each = min.n[x]), simplify = FALSE))
# 
# 
# out <- replicate(10000, {sum(apply(cbind(id, sample(id) * -1), 1, sum) != 0) / length(id)})
# 
# mean(out)

```

```{r read class results, eval = TRUE, echo = FALSE}

agg.inq.classf<- read.csv("./suppl_mat/Classification accuracy by age class INQUIRY.csv", stringsAsFactors = FALSE)

```

Plot mean and SD of classification error (out-of-bag error):

```{r ontogeny of individuality inquiry plots, eval = TRUE, echo = TRUE, fig.height = 4}

agg.inq.classf$age.class <- factor(agg.inq.classf$age.class, levels = c("juveniles", "adults"))

gg.indv.inq <- ggplot(agg.inq.classf, aes(x = age.class, y = 1- oob.error)) + 
  geom_point(size = 2.5, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_errorbar(aes(ymin = 1- oob.error - sd, ymax = 1- oob.error + sd), width=.05, size = 1.2, position = position_dodge(width = 1), col = cols[7], alpha = 1) +
  geom_hline(yintercept = 1- 0.734, lty = 3) +
  # annotate("text", x = 1.5, y = 0.3,  label = "Expected by chance") +
  labs(x = "Age category", y = "Individuality (1-OOB error)") 

gg.indv.inq
```

---

---

## Diagnostic plots for MCMCglmm models

Include MCMC chain trace, autocorrelation plots and Gelman/Rubin's convergence diagnostic:

### Response call ontogeny
```{r diagnostic plots MCMCglmm response ontog, eval = TRUE, echo = TRUE, fig.height= 7}


for(x in 1:length(mods.rsp.ontog)){
  
  print(names(mods.rsp.ontog)[[x]])

  Y <- mods.rsp.ontog[[x]]

  for(j in c("m.age.sex", "m.age", "m.null")){  
    
    print(paste("---model", j))
    
    X <- Y[[j]]
    
    mcmc.l <- mcmc.list(X[[1]]$Sol, X[[2]]$Sol, X[[3]]$Sol)
    
    plot(mcmc.l[[1]], col = cols[1])
  
    plot(mcmc.l[[2]], col = cols[5])
    
    plot(mcmc.l[[3]], col = cols[7])
    
    print("Combining the 3 independent chains")

    plot(mcmc.l, col = cols[c(1, 5, 7)])
    
    autocorr.plot(mcmc.l[[1]], col = cols[1], lwd = 3, ask = FALSE)
    
    autocorr.plot(mcmc.l[[2]], col = cols[5], lwd = 3, ask = FALSE)
    
    autocorr.plot(mcmc.l[[3]], col = cols[7], lwd = 3, ask = FALSE)
    
    print("Gelman and Rubin's convergence diagnostic")
    
    print(gelman.diag(mcmc.l))
      }
  }

```

### Response call non-volant & volant juveniles vs adults
```{r diagnostic plots MCMCglmm response call  non-volant & volant juveniles vs adults, eval = TRUE, echo = TRUE, fig.height= 6}

for(x in 1:length(mds.age.clss.sex.rsp)){
  
  print(names(mds.age.clss.sex.rsp)[[x]])

  Y <- mds.age.clss.sex.rsp[[x]]

  for(j in c("m.age", "m.null")){  
    
    print(paste("---model", j))
    
    X <- Y[[j]]
    
    mcmc.l <- mcmc.list(X[[1]]$Sol, X[[2]]$Sol, X[[3]]$Sol)
    
    plot(mcmc.l[[1]], col = cols[1])
  
    plot(mcmc.l[[2]], col = cols[5])
    
    plot(mcmc.l[[3]], col = cols[7])
    
    print("Combining the 3 independent chains")
    
    plot(mcmc.l, col = cols[c(1, 5, 7)])
    
    autocorr.plot(mcmc.l[[1]], col = cols[1], lwd = 3, ask = FALSE)
    
    autocorr.plot(mcmc.l[[2]], col = cols[5], lwd = 3, ask = FALSE)
    
    autocorr.plot(mcmc.l[[3]], col = cols[7], lwd = 3, ask = FALSE)
    
    print("Gelman and Rubin's convergence diagnostic")
    
    print(gelman.diag(mcmc.l))
      }
  }

```

### Inquiry call juveniles vs adults
```{r diagnostic plots MCMCglmm response call juveniles vs adults inq, eval = TRUE, echo = TRUE, fig.height= 4}

for(x in 1:length(mods.inq.age.class)){
  
  print(names(mods.inq.age.class)[[x]])

  Y <- mods.inq.age.class[[x]]

  for(j in c("m.age", "m.null")){  
    
    print(paste("---model", j))
    
    X <- Y[[j]]
    
    mcmc.l <- mcmc.list(X[[1]]$Sol, X[[2]]$Sol, X[[3]]$Sol)
    
    plot(mcmc.l[[1]], col = cols[1])
  
    plot(mcmc.l[[2]], col = cols[5])
    
    plot(mcmc.l[[3]], col = cols[7])
    
    print("Combining the 3 independent chains")
    
    plot(mcmc.l, col = cols[c(1, 5, 7)])
    
    autocorr.plot(mcmc.l[[1]], col = cols[1], lwd = 3, ask = FALSE)
    
    autocorr.plot(mcmc.l[[2]], col = cols[5], lwd = 3, ask = FALSE)
    
    autocorr.plot(mcmc.l[[3]], col = cols[7], lwd = 3, ask = FALSE)
    
    print("Gelman and Rubin's convergence diagnostic")
    
    print(gelman.diag(mcmc.l))
      }
  }

```

```{r sample sizes, eval=FALSE, echo=FALSE}
rsp1 <- readxl::read_xlsx(".metadata/1_Datos cambios ontogénicos respuesta.xlsx")

# number of times an individual was recorded
table(rsp1$Individuo)

# again number of times an individual was recorded
sapply(unique(rsp1$Individuo), function(x) length(unique(rsp1$`Documento de sonido`[rsp1$Individuo == x])))

#  number of dates an individual was recorded
sapply(unique(rsp1$Individuo), function(x) length(unique(rsp1$Fecha[rsp1$Individuo == x])))

# number of males and females
table(rsp1$Sexo[!duplicated(rsp1$Individuo)])

```


```{r save est as sound files, eval = FALSE, echo = FALSE}

### save inquiry calls
est.inq <- readRDS("./suppl_mat/ext_sel_tab_inquiry.RDS")

est.inq <- resample_est(est.inq, samp.rate = 375)

est.inq <- rename_waves_est(est.inq, new.sound.files = gsub(".wav", "", est.inq$sound.files))

dir.create("./suppl_mat/sound_files_inquiry2")

source("~/Dropbox/R_package_testing/Rraven/Rraven/R/exp_est.R")
st.inq <- exp_est(X = est.inq, single.file = TRUE, path = "./suppl_mat/sound_files_inquiry2", selection.table = FALSE)

cs <- check_sels(st.inq, path = "./suppl_mat/sound_files_inquiry/")

write.csv(st.inq, "selections_inquiry_calls.csv", row.names = TRUE)

st.inq <- read.csv("selections_inquiry_calls.csv", stringsAsFactors = FALSE)

# spectrograms(st.inq[1:20,], wl = 300, path =  "./suppl_mat/sound_files_inquiry/", dest.path =  "./suppl_mat/sound_files_inquiry/")


### save response calls
est.rsp <- readRDS("./suppl_mat/ext_sel_tab_response.RDS")

est.rsp <- resample_est(est.rsp, samp.rate = 375)

new.names <- gsub(".wav", "", est.rsp$sound.files)
new.names <- gsub("-song", "-call", new.names)


est.rsp <- rename_waves_est(est.rsp, new.sound.files = new.names)

dir.create("./suppl_mat/sound_files_response")


source("~/Dropbox/R_package_testing/Rraven/Rraven/R/exp_est.R")

st.rsp <- exp_est(X = est.rsp, single.file = FALSE, path = "./suppl_mat/sound_files_response/", selection.table = FALSE)

cs <- check_sels(st.rsp, path = "./suppl_mat/sound_files_response/")

write.csv(st.rsp, "selections_response_calls.csv", row.names = TRUE)

# spectrograms(st.rsp[1:100, ], wl = 300, path =  "./suppl_mat/sound_files_response/", dest.path =  "./suppl_mat/sound_files_response/", by.song = "sound.files")


```


```{r add data to figshare, eval = FALSE, echo = FALSE}

art.id.part1 <- "11651772"
art.id.part2 <- "11770938"


dt <- fs_details(article_id = art.id.part1, mine = TRUE)


fs.fls <- sapply(dt$files, '[[', 5)
fs.fls.id <- sapply(dt$files, '[[', 3)


any(duplicated(fs.fls))


inq.ann <- read.csv("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/selections_inquiry_calls_annomate.csv", stringsAsFactors = FALSE)

inq.rcs <- unique(inq.ann$source_id)

all(file.exists(file.path("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/sound_files_inquiry", inq.rcs)))

resp.ann <- read.csv("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/selections_response_calls_annomate.csv", stringsAsFactors = FALSE)

 
resp.rcs <- unique(resp.ann$source_id)
 
all(file.exists(file.path("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/sound_files_response/", resp.rcs)))

all.fls <- data.frame(all.fls = c(inq.rcs, resp.rcs), path = c(file.path("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/sound_files_response/", inq.rcs), file.path("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/sound_files_response/", resp.rcs)), stringsAsFactors = FALSE)


# remove duplicates
dt1 <- fs_details(article_id = art.id.part1, mine = TRUE)

dt2 <- fs_details(article_id = art.id.part2, mine = TRUE)

fs.fls <- c(sapply(dt2$files, '[[', 5), sapply(dt$files, '[[', 5))

any(duplicated(fs.fls))

all(all.fls$all.fls %in% fs.fls)

mss.all <- all.fls[!all.fls$all.fls %in% fs.fls,]


nrow(mss.all)

if (nrow(mss.all) > 0)
out <- pbsapply(mss.all$path, function(x) fs_upload(article_id = art.id.part2, file = x))


##### add to part 2

# id <- fs_create("Supplementary materials: Ontogeny of an interactive call-and-response system in Spix’s disc-winged bats. PART 2", 'Part 1 of supplementary materials of the paper "Ontogeny of an interactive call-and-response system in Spix’s disc-winged bats". The data contains raw acoustic data, individual`s metadata and outputs of model selection procedures and model parameter estimations.')



```


```{r figshare, eval = FALSE, echo = FALSE}



art.id.part1 <- "11651772"
art.id.part2 <- "11770938"


p1 <- fs_details(article_id = art.id.part1, mine = TRUE)
p2 <- fs_details(article_id = art.id.part2, mine = TRUE)


fs.fls <- sapply(dt$files, '[[', 5)
fs.fls.id <- sapply(dt$files, '[[', 3)


inq.ann <- read.csv("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/selections_inquiry_calls_annomate.csv", stringsAsFactors = FALSE)

all(file.exists(file.path("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/sound_files_inquiry", inq.ann$source_id)))

resp.ann <- read.csv("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/selections_response_calls_annomate.csv", stringsAsFactors = FALSE)

all(file.exists(file.path("/home/m/Dropbox/Projects/Ontogenia respuesta Thyroptera/suppl_mat/sound_files_response/", resp.ann$source_id)))





```


---

<font size="4">R session information</font>

```{r session info, echo=F}

sessionInfo()

```