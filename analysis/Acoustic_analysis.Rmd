---
title: <center><font size="7"><b>Acoustic analysis</b></font></center>
subtitle: <center><font size="4"><b>Hummingbird song evolution</b></font></center>
author: <center><font size="4"><a href="http://marceloarayasalas.weebly.com/">Marcelo Araya-Salas, PhD</a></font></center>
#date: <center>`r format(Sys.Date(), "%d-%m-%Y")`</center>
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: no
      smooth_scroll: no
fontsize: 12pt 
editor_options: 
  chunk_output_type: console
---

```{r packages, message=FALSE, warning = FALSE, echo = FALSE, eval = TRUE, include = FALSE}

rm(list = ls())

# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))

## add 'developer/' to packages to be installed from github
x <-
  c(
  "ggplot2",
  "RColorBrewer",
  "fossil",
  "stringdist",
  "maRce10/warbleR",
  "parallel",
  "ape",
  "phytools",
  "pbapply",
  "caret",
  "TraMineR",
  "corrplot",
  "viridis",
  "smacof",
  "randomForest",
  "geiger",
  "kableExtra",
  "knitr",
  "missMDA",
  "tuneRanger",
  "mlr"
  )
  
aa <- lapply(x, function(y) {
  # get pakage name
  pkg <- strsplit(y, "/")[[1]]
  pkg <- pkg[length(pkg)]
  
  # check if installed, if not then install
  if (!pkg %in% installed.packages()[, "Package"])  {
  if (grepl("/", y))
  devtools::install_github(y, force = TRUE)
  else
  install.packages(y)
  }
  
  # load package
  try(require(pkg, character.only = T), silent = T)
})

```

```{r functions and parameters, message = FALSE, warning = FALSE, echo = FALSE, eval = TRUE}

## functions #######

# capitalize genera
spCap <- function(x, sep = " ") {
  out <- sapply(x, function(y) {
  s <- strsplit(y, sep)[[1]]
  paste0(toupper(substring(s[1], 1, 1)),
  tolower(substring(s[1], 2)),
  sep,
  tolower(s[2]))
  })
  names(out) <- NULL
  return(out)
}


# random sound
# source('~/Dropbox/R package testing/warbleR/Beta functions/random_sound.R')
# rs <- function() random_sound(dur = 2, segment.dur.range = c(0.01, 0.9), frange = c(1, 2))

# source('C:/Users/itloaner/Dropbox/warbleR/R/phylo_spectro.R')

# parameters ########
options("digits" = 5, "digits.secs" = 5, knitr.table.format = "html") 

cols <- brewer.pal(10,"Spectral")


warbleR_options(sound.sel.path = "./sound selection files/MARCELO USE ONLY/finished (linux)", wav.path = "./Acoustic analysis/Recordings", wl = 300, flim = "frange", ovl = 90, parallel = if (Sys.info()[1] == "Windows") 1 else detectCores() -1)


# sequence complexity
sq_complx <- function(x) {
    if(length(unique(x)) == 1) sc <- 0 else
  sc <- suppressMessages(seqici(seqdef(t(x), informat='STS')))
  
    return(sc)
    }

# transition diversity (ratio of transition between different elements to transitions between similar elements)
trans_div <- function(x) {
  
  if(length(unique(x)) == 1) td <- 0 else{
  sq.seq <- seqdef(t(x), informat='STS')

    sr <- seqtrate(sq.seq, count = TRUE)

  td <- sum(sr[!diag(sr)]) / sum((sr))
}
  
  return(td)
  }

trans_div2 <- function(x) try_na(suppressMessages(trans_div(x)))


# mean pairwise sequence distance among all sequences of a bird
# X most have a song label and element label column
# y is the name of the sound file
btwn.song.vrn <- function(X, y) {
  
  x <- X$element[X$sound.files == y]
  songlab <- X$song.lab[X$sound.files == y]
  
  if (length(unique(songlab)) == 1) mn.sq.dst <- NA else{ 
  
    xlst <-split(x, songlab)
    
    mxl <- max(sapply(xlst, length))
    
    # add NA to short ones
    xlst <- lapply(xlst, function(x) c(x, rep(NA,  mxl - length(x))))
    
    # put it in a data frame
    xlst <- do.call(rbind, xlst)
    
    suppressMessages(sq.seq <- seqdef(xlst, informat='STS'))

    suppressMessages(sqdst <- seqdist(seqdata = sq.seq, method = "OM", sm = "CONSTANT", norm = "auto"))
    
    mn.sq.dst <- mean(sqdst[upper.tri(sqdst)])
  }
  return(mn.sq.dst)
  }

# btwn.song.vrn <- function(X, y) suppressMessages(btwn.song.vrn(X, y))

range01 <- function(x){
  x <- x + min(x)
  return((x-min(x))/(max(x)-min(x)))
  }

se <- function(x) sd(x)/sqrt(length(x))

# source('/m/Dropbox/Documentos_R/Functions/fuzzy search of species names.R')

options(knitr.table.format = "html") 

```

```{r measure acoustic parameters on elements, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}

sels <- read.csv("Selections for checked species.csv", stringsAsFactors = FALSE)

length(unique(sels$Species))


names(sels)

# sels <- sels[sels$Clade != "Swifts", ]

sp.param <- specan(sels, threshold = 0, harmonicity = FALSE)

# number of NAs
sapply(sp.param, function(x) sum(is.na(x)))

sp.param <- merge(sp.param, sels[, c("Species", "Clade", "sound.files", "selec", "start", "end", "element_labels", "song", "song.lab", "element", "SNR")])

# species by clade
table(sp.param$Clade[!duplicated(sp.param$Species)])

write.csv(sp.param, "Element parameters hummingbirds and swifts.csv", row.names = FALSE)

# read tree
tr318 <- read.tree("consensus_tree_swifts_hummingbirds_and_nighjars_max_cred.tree")

```

```{r measure acoustic parameters caprimulgidae, include= FALSE}

sels <- read.csv("./data/raw/caprimulgidae_consolidated_warbler_sel_tab.csv")

cs <- check_sels(sels)

est.cap <- selection_table(sels, extended = TRUE, confirm.extended = FALSE)

est.cap$channel.1 <- NULL

# est_apo was read from previous s
est <- rbind(est.cap, est_apo)

setdiff(names(est.cap), names(est_apo))
setdiff(names(est_apo), names(est.cap))

sp.param <- specan(sels, threshold = 0, harmonicity = FALSE)

# number of NAs
sapply(sp.param, function(x) sum(is.na(x)))

sp.param <- merge(sp.param, sels[, c("Species", "Clade", "sound.files", "selec", "start", "end", "element_labels", "song", "song.lab", "element", "SNR")])

# species by clade
table(sp.param$Clade[!duplicated(sp.param$Species)])

write.csv(sp.param, "Element parameters nighjars.csv", row.names = FALSE)

ap <- read.csv("Element parameters hummingbirds and swifts.csv", stringsAsFactors = FALSE)

ap.all <- rbind(ap, sp.param)

write.csv(ap.all, "Element parameters nighjars swifts and hummingbirds.csv", row.names = FALSE)


```

```{r element acoustic space unsupervised random forest, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}

# read data
ap <- read.csv("Element parameters nighjars swifts and hummingbirds.csv", stringsAsFactors = FALSE)

#check SNR
hist(ap$SNR)

# select variables excluding dominant freq variables
vars <- grep("sound.files|selec|start|end|top.freq|bottom.freq|Species|Clade|element|song|SNR|seq", names(ap), invert = TRUE)

# get correlations 
snr.cor <- sapply(ap[, vars], function(x) cor(x, ap$SNR))

# check variables correlated to SNR ones
if (any(abs(snr.cor) > 0.5)) "some variables correlate with SNR"

# check collinearity
cm <- cor(ap[, vars])

# remove highly correlated vars
high.corr <- findCorrelation(cm, cutoff = .95)

print("Removed colinear parameters (r > 0.95)")
(hc.vars <- names(ap)[vars][high.corr])

# keep duration
hc.vars <- hc.vars[hc.vars != "duration"]

# remove collinear ones
ap <- ap[, !names(ap) %in% hc.vars]

vars <- grep("sound.files|selec|start|end|top.freq|bottom.freq|Species|Clade|element|song|SNR|seq", names(ap), invert = TRUE)

ap[, vars] <- scale(ap[, vars], scale = TRUE, center = TRUE)

sapply(ap[, vars], function(x) any(is.nan(x)))

set.seed(27) 
urf.elm <- randomForest(ap[, vars], keep.forest = FALSE, proximity=TRUE, ntree = 10000)

urf.elm <- ranger(ap[, vars], keep.forest = FALSE, proximity=TRUE, ntree = 10000)

saveRDS(urf.elm, "Unsupervised random forest results 318 species test by element.RDS")

```

```{r MDS on element RF, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}

urf.elm <- readRDS("Unsupervised random forest results 318 species test by element.RDS")

# sum(urf.elm$votes[,2] > urf.elm$votes[,1]) / nrow(urf.elm$votes)


rf.dist <- as.data.frame(urf.elm$proximity)

rf.dist <- sqrt(1 - rf.dist)

# rf.dist <- (1 - urf.elm$proximity)

rf.mds <- cmdscale(rf.dist, k = 2)

saveRDS(rf.mds, "MDS random forest elements nightjars swifts and hummingbirds.RDS")

# fit <- metaMDS(comm = as.dist(rf.dist), k = 2, distance = "euclidean")
# 
# fit  <- mds(rf.dist, ndim = 2)
# 
# 
# saveRDS(fit, "MDS initial fit.RDS")
# 
# mds.rf <- bootmds(fit, rf.dist, method.dat = "euclidean", nrep = 50)
# 
# saveRDS(mds.rf, "bootstrap MDS random forest elements.RDS")

```

```{r measure acoustic parameters and complexity on songs, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}

# read selection
# sels <- read.csv("Selections for checked species.csv", stringsAsFactors = FALSE)

# read data
sp.param <- read.csv("Element parameters nighjars swifts and hummingbirds.csv", stringsAsFactors = FALSE)


# sort columns
sp.param <- sort_colms(sp.param)

# calculate parameters at the song level
song.sp <- song_param(sp.param, song_colm = "song.lab", 
                      elm_colm = "element_labels", elm_fun = sq_complx)

# name elm_fun column
names(song.sp)[ncol(song.sp)] <- "sq.complx"

# calculate transition diversity
song.sp$trans.div <- song_param(sp.param, song_colm = "song.lab", elm_colm = "element_labels", elm_fun = trans_div2)[, ncol(song.sp)]

# add sequence
song.sp$seq <- song_param(sp.param, song_colm = "song.lab", elm_colm = "element_labels", elm_fun = function(x) paste(x, collapse = "-"))[,ncol(song.sp) - 1]

# Correct complexity by number of element type
song.sp$c.sq.complx <- song.sp$sq.complx / song.sp$elm.types

# read RF data
# urf.elm <- readRDS("random forest results 250 species test by element.RDS")

# urf.elm <- readRDS("Unsupervised random forest results 296 species test by element.RDS")

urf.elm <- readRDS("Unsupervised random forest results 318 species test by element.RDS")

# error rate
sum(urf.elm$votes[,2] > urf.elm$votes[,1]) / nrow(urf.elm$votes)

# read selections and measures
ap <- read.csv("Element parameters nighjars swifts and hummingbirds.csv", stringsAsFactors = FALSE)

# exclude smallest clades (has to be the same data used in RF)
# ap <- ap[ap$Clade != "Swifts", ]

# mean pairwise distance of elements within a song using RF proximity
# song.sp$mean.dist <- pbsapply(1:nrow(song.sp), cl = 3,  function(x){
#   
#   indx <- ap$sound.files == song.sp$sound.files[x] & ap$song.lab == song.sp$song.lab[x]
#   
#   if(sum(indx) == 1) return(0) else
#   {  
#     X <- (1 - urf.elm$proximity[indx, indx])
# 
#     mean.prox <- mean(X[upper.tri(X)])
# 
#     return(mean.prox)
#   }
# })

# rf.mds <- readRDS("MDS random forest elements.RDS")
rf.mds <- readRDS("MDS random forest elements nightjars swifts and hummingbirds.RDS")

    # rf.mds[, 1] <- rf.mds[, 1] + abs(min(X[, 1]))
    rf.mds[, 1] <- rf.mds[, 1] / max(rf.mds[, 1])
    rf.mds[, 2] <- rf.mds[, 2] / max(rf.mds[, 2])


#  song acoustic space from MDS RF proximity
song.sp$acous.spc <- pbsapply(1:nrow(song.sp), cl = 1,  function(x){
  
  indx <- ap$sound.files == song.sp$sound.files[x] & ap$song.lab == song.sp$song.lab[x]
  
  if(sum(indx) < 3) return(0) else
  {  
   
    X <- rf.mds[indx, ]
    
    area <- try(as.numeric(earth.poly(X)$area), silent = TRUE)

    if(class(area) == "try-error") return(NA) else
  return(area)
  }
})

hist(song.sp$acous.spc)

song.sp$btwn.song.var <- pbsapply(song.sp$sound.files, function(x) btwn.song.vrn(X = sp.param, y = x), cl = detectCores() - 1)

write.csv(song.sp,"Song parameters nightjars swifts and hummingbirds.csv", row.names = FALSE)

```

```{r PCA song complexity measures, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}

song.sp <- read.csv("Song parameters nightjars swifts and hummingbirds.csv", stringsAsFactors = FALSE)

# check collinearity
cm <-  cor(song.sp[, !grepl("sound.files|selec|start|end|top.freq|bottom.freq|Species|Clade|element|song|SNR|seq|clade|species", names(song.sp))], use = "pairwise.complete.obs")

# visualize collinearity
corrplot.mixed(cm,  lower = "ellipse", upper = "number", tl.pos = "lt")

cm <-  cor(song.sp[, c("elm.types", "mean.elm.count", "sq.complx", "trans.div", "c.sq.complx", "acous.spc", "btwn.song.var")], use = "pairwise.complete.obs")

# visualize collinearity for complexity measures
corrplot.mixed(cm, lower = "ellipse", upper = "number", tl.pos = "lt")

# removing 0s (many 0s could inflate correlation)
cm <-  cor(song.sp[song.sp$acous.spc != 0, c("elm.types", "mean.elm.count", "sq.complx", "trans.div", "c.sq.complx", "acous.spc", "btwn.song.var")], use = "pairwise.complete.obs")

# visualize collinearity for complexity measures
corrplot.mixed(cm, lower = "ellipse", upper = "number", tl.pos = "lt")

# find columns with NAs
names(song.sp)[sapply(song.sp, function(x) sum(is.na(x))) != 0]
# song.sp <- song.sp[, !sapply(song.sp, anyNA)]

# add metadata
sels <- read.csv("hummingbirds_swifts_and nightjars_consolidated_warbler_sel_tab.csv", stringsAsFactors = FALSE)

song.sp <- merge(song.sp, sels[!duplicated(sels$sound.files), c("Species", "Clade", "sound.files")], all.x = FALSE)

# calculate PCA for complexity
complx.vars <- (song.sp[, c("elm.types", "sq.complx", "acous.spc", "btwn.song.var")])

# Impute missing values 
nb <- estim_ncpPCA(complx.vars, ncp.max = 4) ## Time consuming, nb = 2

complx.vars <- as.matrix(imputePCA(complx.vars, ncp = nb$ncp)$completeObs)

song.sp$btwn.song.var.IMP <- complx.vars[, 4]

# non phylogenetic
pca.complx <- princomp(complx.vars,  cor = TRUE)

summary(pca.complx)

pca.complx$loadings

saveRDS(pca.complx, "PCA complexity.RDS")

song.sp$species_uscr <- gsub(" ", "_", song.sp$Species)

#phylogenetic pca
agg.complx.vars <- aggregate(complx.vars, by = list(song.sp$species_uscr), mean, na.rm = TRUE)

row.names(agg.complx.vars) <- agg.complx.vars$Group.1

phy.pca.complx <- phyl.pca(tree = tr318, Y = agg.complx.vars[, -1],  mode = "corr", method = "lambda")

saveRDS(phy.pca.complx, "phylogenetic PCA complexity.RDS")


summary(pca.complx)
# 
# pca.complx$loadings

song.sp$pca.complx <- pca.complx$scores[, 1]

# add species and name
sels <- read.csv("hummingbirds_swifts_and nightjars_consolidated_warbler_sel_tab.csv", stringsAsFactors = FALSE)

song.sp$species <- sapply(song.sp$sound.files, function(x) sels$Species[sels$sound.files == x][1])

song.sp$species_uscr <- gsub(" ", "_", song.sp$species)

song.sp$Clade <- sapply(song.sp$sound.files, function(x) sels$Clade[sels$sound.files == x][1])

write.csv(song.sp, "Song parameters nightjars swifts and hummingbirds.csv", row.names = FALSE)

# species averages
sp.complx <- aggregate(song.sp[, c("elm.types", "sq.complx", "acous.spc", "btwn.song.var", "pca.complx", "btwn.song.var.IMP")], by = list(song.sp$species_uscr), mean, na.rm = TRUE)

names(sp.complx)[1] <- "species"

sp.complx$clade <- sapply(sp.complx$species, function(x) sels$Clade[sels$Species_uscr == x][1])

sp.complx <- sp.complx[, c("species", "clade", "elm.types", "sq.complx", "acous.spc", "btwn.song.var", "btwn.song.var.IMP", "pca.complx")]

write.csv(sp.complx, "Species mean song complexity parameters nightjars swifts and hummingbirds.csv", row.names = FALSE)

#median
sp.complx.med <- aggregate(song.sp[, c("elm.types", "sq.complx", "acous.spc", "btwn.song.var", "pca.complx", "btwn.song.var.IMP")], by = list(song.sp$species_uscr), median, na.rm = TRUE)

names(sp.complx.med)[1] <- "species"

sp.complx.med$clade <- sapply(sp.complx.med$species, function(x) sels$Clade[sels$Species_uscr == x][1])

sp.complx.med <- sp.complx.med[, c("species", "clade", "elm.types", "sq.complx", "acous.spc", "btwn.song.var", "btwn.song.var.IMP", "pca.complx")]

write.csv(sp.complx.med, "Species median song complexity parameters nightjars swifts and hummingbirds.csv", row.names = FALSE)

all.song.complx <- song.sp[, c("species_uscr", "elm.types", "sq.complx", "acous.spc", "btwn.song.var", "pca.complx", "btwn.song.var.IMP")]


names(all.song.complx)[1] <- "species"

write.csv(all.song.complx, "All songs complexity parameters nightjars swifts and hummingbirds.csv", row.names = FALSE)


sapply(all.song.complx[, sapply(all.song.complx, is.numeric)], range, na.rm = T)


all.song.complx$elm.types <- log10(all.song.complx$elm.types)
all.song.complx$sq.complx <- log10(all.song.complx$sq.complx + 1)
all.song.complx$acous.spc <- log10(all.song.complx$acous.spc  + 1)
all.song.complx$pca.complx <- log10(all.song.complx$pca.complx + abs(min(all.song.complx$pca.complx)) + 1)

all.song.complx$btwn.song.var <- log10(all.song.complx$btwn.song.var  + 1)

all.song.complx$btwn.song.var.IMP <- log10(all.song.complx$btwn.song.var.IMP  + 1)

write.csv(all.song.complx, "log10 songs complexity parameters nightjars swifts and hummingbirds.csv", row.names = FALSE)

sapply(all.song.complx[, sapply(all.song.complx, is.numeric)], range, na.rm = T)


```

```{r supervised random forest by clade element level, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}

# read data
ap <- read.csv("Element parameters nighjars swifts and hummingbirds.csv", stringsAsFactors = FALSE)

# exclude smallest clades
ap <- ap[!ap$Clade %in% c("Patagona", "Topazes"),]

# is there any column with NAs
if (any(sapply(ap, anyNA))) print("some columns have NAs")
ap <- ap[, !sapply(ap, anyNA)]

# get indx for acoustic parameters to include
ap.vars <- !grepl("sound.files|selec|start|end|top.freq|bottom.freq|Species|Clade|element|song|SNR", names(ap), ignore.case = TRUE)
names(ap)[ap.vars]

# scale
ap[, ap.vars] <- scale(ap[, ap.vars], center = T, scale = T)

# is there any column with NAs
if (any(sapply(ap, function(x) any(is.nan(x))))) print("some columns have NAs")
ap.trans <- ap[, !sapply(ap, function(x) any(is.nan(x)))]

ap.vars <- !grepl("sound.files|selec|start|end|top.freq|bottom.freq|Species|Clade|element|song|SNR", names(ap.trans), ignore.case = TRUE)

# check collinearity
cm <- cor(ap.trans[, ap.vars])

# remove highly correlated vars
high.corr <- findCorrelation(cm, cutoff = .95)

print("Removed colinear parameters (r > 0.95)")
(hc.vars <- names(ap.trans)[ap.vars][high.corr])

# keep interquantile
hc.vars <- hc.vars[hc.vars != "duration"]

# remove collinear ones
ap.trans <- ap.trans[, !names(ap.trans) %in% hc.vars]

# head(ap.trans)

# get indx for acoustic parameters to include again
ap.vars <- grep("sound.files|selec|start|end|top.freq|bottom.freq|Species|Clade|element|song|SNR", names(ap.trans), value = TRUE, invert = TRUE, ignore.case = TRUE)

# add random variable
ap.trans$rndm <- rnorm(n = nrow(ap.trans))

# add name to variable indxs
ap.vars <- c(ap.vars, "rndm")


clade.task = makeClassifTask(data = ap.trans[, c("Clade", ap.vars)], target = "Clade")
 
# Estimate runtime
# estimateTimeTuneRanger(clade.task, num.trees = 10000, num.threads = 3)

# Tuning
res <- tuneRanger(clade.task, measure = list(multiclass.brier), num.trees = 1000, 
  num.threads = 3, iters = 70, save.file.path = "optpath.RData")

# rf.clade.elem <- predict(res$model, newdata = ap.trans[, c("Clade", ap.vars)])

# run random forest
rf.clade.elem <- ranger(Clade ~ ., data = ap.trans[, c("Clade", ap.vars)], num.trees = 10000, importance = "impurity", mtry = res$recommended.pars$mtry, min.node.size = res$recommended.pars$min.node.size, sample.fraction = res$recommended.pars$sample.fraction)

# pm <- extract_proximity(rf.clade.elem, newdata = ap.trans[, c("Clade", ap.vars)])

# length(unique(ap$Species))

fr.elem.res <- list(data = "318.species", proximity = NA, importance = rf.clade.elem$variable.importance,  error = rf.clade.elem$prediction.error, confusion = rf.clade.elem$confusion.matrix)

# song.imp <- importance_pvalues(rf.song, method = "altman", formula = species ~ ., data = ap[, ap.vars])

saveRDS(fr.elem.res, "supervised random forest clades results 318 species test by element.RDS")

```

```{r random forest by clade song level, message = FALSE, warning = FALSE, echo = FALSE, eval = FALSE}

# read data
ap <- read.csv("Element parameters nighjars swifts and hummingbirds.csv", stringsAsFactors = FALSE)

# exclude smallest clades
ap <- ap[!ap$Clade %in% c("Patagona", "Topazes"), ]

# is there any column with NAs
if (any(sapply(ap, anyNA))) print("some columns have NAs")
ap <- ap[, !sapply(ap, anyNA)]

# get indx for acoustic parameters to include
ap.vars <- !grepl("sound.files|selec|start|end|top.freq|bottom.freq|species|Clade|element|song.lab|SNR|seq|mean.dist|c.sq.complx|pca|trans.div|song", names(ap), ignore.case = TRUE)
names(ap)[ap.vars]

# z-transform
ap[, ap.vars] <- scale(ap[, ap.vars], center = T, scale = T)

# check of NAn
if (any(sapply(ap, function(x) any(is.nan(x))))) print("some columns have NAs")
ap.trans <- ap[, !sapply(ap, function(x) any(is.nan(x)))]

# get indx for acoustic parameters to include again
ap.vars <- !grepl("sound.files|selec|start|end|top.freq|bottom.freq|species|Clade|element|song.lab|SNR|seq|mean.dist|c.sq.complx|pca|trans.div|song", names(ap.trans), ignore.case = TRUE)

# collinear variables
cm <- cor(ap.trans[, ap.vars])

# remove highly correlated vars
high.corr <- findCorrelation(cm, cutoff = .95)

# which ones are collinear
print("Removed colinear parameters (r > 0.95)")
(hc.vars <- names(ap.trans)[ap.vars][high.corr])

# keep meandom
hc.vars <- hc.vars[!hc.vars %in% c("meandom", "duration")]

ap.trans <- ap.trans[, !names(ap.trans) %in% hc.vars]

# head(ap.trans)
ap.vars <- grep("sound.files|selec|start|end|top.freq|bottom.freq|species|Clade|element|song.lab|SNR|seq|mean.dist|c.sq.complx|pca|trans.div|song", ignore.case = TRUE, names(ap.trans), value = TRUE, invert = TRUE)

ap.trans$rndm <- rnorm(n = nrow(ap.trans))
ap.vars <- c(ap.vars, "rndm")

ap.trans$Clade <- as.factor((ap.trans$Clade))

set.seed(27)
# rf.clade.songRF <- randomForest(Clade ~ ., data = ap.trans[, c("Clade", ap.vars)], keep.forest = FALSE, proximity=TRUE, ntree = 10000)


clade.task <- makeClassifTask(data = ap.trans[, c("Clade", ap.vars)], target = "Clade")
 
# Tuning
res <- tuneRanger(clade.task, measure = list(multiclass.brier), num.trees = 1000, 
  num.threads = 3, iters = 70)

# rf.clade.elem <- predict(res$model, newdata = ap.trans[, c("Clade", ap.vars)])

# Using ranger
rf.clade.song <- ranger(Clade ~ ., data = ap.trans[, c("Clade", ap.vars)], num.trees = 10000, importance = "impurity", mtry = res$recommended.pars$mtry, min.node.size = res$recommended.pars$min.node.size, sample.fraction = res$recommended.pars$sample.fraction)

#or if don't want to run tuneRanger again (tuning parameters were obtained from tuneRanger)
rf.clade.song <- ranger(Clade ~ ., data = ap.trans[, c("Clade", ap.vars)], num.trees = 10000, importance = "impurity", mtry = 12, min.node.size = 2, sample.fraction = 0.8978)

 
pm.song <- edarf::extract_proximity(rf.clade.song, newdata = ap.trans[, c("Clade", ap.vars)])

res.rf.song <-list(data = "318.species", proximity = pm.song, importance = rf.clade.song$variable.importance,  error = rf.clade.song$prediction.error, confusion = rf.clade.song$confusion.matrix, RF = NA)



# song.imp <- importance_pvalues(res.rf.song, method = "altman", formula = species ~ ., data = ap[, ap.vars])

saveRDS(res.rf.song, "supervised random forest clades results 318 species test by song.RDS")

```

```{r Bootstrap song random forest for per-clade variable importance, eval = FALSE, echo = FALSE,  fig.width = 8}

## run previous chuck until "set.seed(27)"
ap.trans$Clade <- as.character(ap.trans$Clade)

# selec representative variables
ap.trans <- ap.trans[, c("Clade", "meanfreq", "freq.IQR", "entropy", "num.elms", "mean.elm.count", "sq.complx", "acous.spc", "btwn.song.var.IMP", "rndm", "duration", "song.duration")]

# loop to get bootstrapped var importance and error 
out <- pblapply(unique(ap.trans$Clade), cl = 3, function(x){
  
  #target clade
  X <- ap.trans[ap.trans$Clade == x, ]
  
  # other clades
  Y <- (ap.trans[ap.trans$Clade != x, ])
  
  # proportion of total samples
  prp <- nrow(X) / nrow(Y)
  
  trainIndex <- createDataPartition(Y$Clade, p = prp, list = TRUE, times = 30)

  Y$Clade <- "other.clades"
  
  rfout <- lapply(trainIndex, function(y){ 
    
    Z <- rbind(X, Y[y, ])
    
    rf.clade.song <- ranger(Clade ~ ., data = Z, num.trees = 1000, importance = "impurity")
    
rf.clade.song$variable.importance <- range01(rf.clade.song$variable.importance / rf.clade.song$variable.importance[names(rf.clade.song$variable.importance) == "rndm"])
    
    res <- data.frame(target.clade = x, importance = t(rf.clade.song$variable.importance),  error = rf.clade.song$prediction.error, class.error = rf.clade.song$confusion.matrix[1, 2] / nrow(X))
  })

rfout <- do.call(rbind, rfout)
 
return(rfout)   
})

rfres <- do.call(rbind, out)

rownames(rfres) <- 1:nrow(rfres)

write.csv(rfres, "Bootstrapped random forest variable importance by clade 318 species.csv", row.names = FALSE)

```


### Random forest classification

#### Classification of clades using song level attributes

Patagona and Topazes were excluded

Classification accuracy at the element level:

```{r random forest element, eval = TRUE, echo = FALSE,  fig.width = 8}

conf <- readRDS("random forest results 291 species test by element.RDS")$confusion

for(i in 1:nrow(conf))
conf[i, ] <- conf[i, ] / sum(conf[i, ])

corrplot(conf, method = "pie",  is.corr = T, col = viridis::inferno(10), tl.col = "black", p.mat = conf, insig = "p-value", sig.level = -1) 

```

Classification accuracy at the song level:

```{r random forest song, eval = TRUE, echo = FALSE,  fig.width = 8}

conf <- readRDS("random forest results 318 species test by element.RDS")$confusion

for(i in 1:nrow(conf))
conf[i, ] <- conf[i, ] / sum(conf[i, ])

#ranger package
corrplot(conf, method = "pie",  is.corr = T, col = viridis::inferno(10), tl.col = "black", p.mat = conf, insig = "p-value", sig.level = -1) 

# conf <- rf.song$RF$confusion[,-8]
# 
# for(i in 1:nrow(conf))
# conf[i, ] <- conf[i, ] / sum(conf[i, ])
# 
# corrplot(conf, method = "pie",  is.corr = T, col = viridis::inferno(10), tl.col = "black", p.mat = conf, insig = "p-value", sig.level = -1, title = "randomForest package") 

```

 Relative importance (contribution) of song attributes to classification
 
 >  Sequence complexity (*corrected.complx*): a composite measure of sequence complexity. The index uses the number of transitions in the sequence as a measure of the complexity induced by the state ordering and the longitudinal entropy as a measure of the complexity induced by the state distribution in the sequence

```{r random forest results, eval = TRUE, echo = FALSE, fig.width = 8}

imp <- data.frame(var = names(rf.song$importance), imp = rf.song$importance)

imp <- imp[imp$imp > imp$imp[imp$var == "rndm"], ]

imp$`Parameter type` <- c("Time", rep("Frequency", 5), rep("Spectral density (amp)", 5), rep("Frequency", 8), "Sequence complexity", "Frequency", "Time",  rep("Sequence complexity", 5))

imp$var <- factor(imp$var, levels = imp$var[order(imp$imp)])

imp$`Parameter type` <- factor(imp$`Parameter type`, levels = unique(imp$`Parameter type`)[c(1, 3, 2, 4)])

ggplot(data = imp, aes(x = var, y = imp, fill = `Parameter type`)) + geom_bar(stat = "identity") +
    theme_classic() + 
  labs(y = "Random Forest importance", x = "Song parameter") +
  scale_fill_manual(values=viridis::inferno(10)[c(8, 6, 4, 2)]) + coord_flip() 

```

Aggregated importance by parameter type

```{r random forest results2, eval = TRUE, echo = FALSE,  fig.width = 8}

type.imp <- aggregate(imp[,"imp"], by = list(imp$`Parameter type`), FUN = mean)

names(type.imp) <- c("Parameter type", "imp")

type.imp$`Parameter type` <- factor(type.imp$`Parameter type`, levels = unique(type.imp$`Parameter type`)[c(4, 2, 3, 1)])

ggplot(data = type.imp, aes(x = `Parameter type`, y = imp, fill = `Parameter type`)) + geom_bar(stat = "identity") +
    theme_classic() +
    labs(y = "Aggregated Random Forest importance", x = "Parameter type") +
  scale_fill_manual(values=viridis::inferno(10)[c(2, 4, 6, 8)]) + coord_flip() 

```


Aggregated importance by parameter type boostrapped by clade

```{r random forest bootstrap, eval = TRUE, echo = FALSE, fig.width = 8, warning= FALSE}

rfres <- read.csv("Bootstrapped random forest variable importance by clade 291 species.csv", stringsAsFactors = FALSE)

names(rfres) <- gsub("importance.", "", names(rfres))

ap <- read.csv("Song parameters hummingbirds and swifts.csv", stringsAsFactors = FALSE)

# convert to range 0-1
for(i in names(rfres)[-c(1, 13, 10, 14)])
  ap[, i] <- range01(ap[, i])
  
agg.imp <- aggregate(rfres[, - 1], by = list(rfres$target.clade), FUN = mean)
sd.imp <- aggregate(rfres[, - 1], by = list(rfres$target.clade), FUN = sd)

lagg.imp <- tidyr::gather(agg.imp, variable, importance, meanfreq:class.error)
lsd.imp <- tidyr::gather(sd.imp, variable, sd, meanfreq:class.error)

lagg.imp$imp.sd <- lsd.imp$sd
names(lagg.imp)[1] <- "clade"


lagg.imp$mean <- sapply(1:nrow(lagg.imp), function(x) {
  mean(ap[ap$Clade == lagg.imp$clade[x], names(ap) == lagg.imp$variable[x]])
})

lagg.imp$sd <- sapply(1:nrow(lagg.imp), function(x) {
  sd(ap[ap$Clade == lagg.imp$clade[x], names(ap) == lagg.imp$variable[x]])
})

lagg.imp$se <- sapply(1:nrow(lagg.imp), function(x) {
  se(ap[ap$Clade == lagg.imp$clade[x], names(ap) == lagg.imp$variable[x]])
})



# lagg.imp$upCI <- lagg.imp$mean + lagg.imp$sd
# lagg.imp$loCI <- lagg.imp$mean - lagg.imp$sd

# out <- lapply(unique(lagg.imp$variable), function(x){
#   
#   X <- lagg.imp[lagg.imp$variable == x, ]
#   
#   msd <- X$sd / X$mean
#   
#   X$mean <- range01(X$mean)
#   
#   X$sd <- msd #* X$mean
#   
#   return(X)
# })
#   

# lagg.imp <- do.call(rbind, out)  

lagg.imp <- lagg.imp[grep("error|rndm|btwn.song", lagg.imp$variable, invert = TRUE), ]

# select the 4 most important variables
# lagg.imp <- lagg.imp[ave(-lagg.imp$importance, lagg.imp$clade, FUN = rank) <= 8, ]

lagg.imp <- lagg.imp[order(lagg.imp$clade, lagg.imp$importance),]

# by importance
ggplot(data = lagg.imp, aes(x = variable, y = importance)) + 
  geom_point(col = inferno(10)[5]) +
  theme_classic() +
  facet_wrap(~clade, nrow = 2, scales = "free") +
 geom_errorbar(aes(ymin = importance - imp.sd, ymax = importance + imp.sd), colour=inferno(10)[5], width=.1) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  coord_flip() 

# by raw variables
ggplot(data = lagg.imp, aes(x = variable, y = mean, fill = importance)) + 
  # geom_point() +
  geom_bar(stat = "identity", width = 0.5) +
  theme_classic() +
  # ylim(c(0, 1)) +
  facet_wrap(~clade, nrow = 2, scales = "fixed") +
 geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width=.1) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_gradientn(colours = rev(inferno(100)[51:100])) +
  coord_flip() 


```

### Clade song structure

```{r Clade song structure, eval = TRUE, echo = FALSE,  fig.width = 8}

song.sp <- read.csv("Song parameters hummingbirds and swifts.csv", stringsAsFactors = FALSE)

names(song.sp)[8] <- "elem.duration"

out <- lapply(c("elem.duration", "meanfreq", "sd", "song.duration", "acous.spc", "elm.types", "mean.elm.count", "sq.complx", "trans.div"), function(x) {

X <- aggregate(song.sp[, x], by = list(song.sp$Clade), mean)
names(X) <- c("clade", "mean")

X$var <- x
X <- X[, c(1,3, 2)]

X$sd <- aggregate(song.sp[, x], by = list(song.sp$Clade), sd)[, 2]
X$se <- aggregate(song.sp[, x], by = list(song.sp$Clade), se)[, 2]

return(X)
})

clade.means <- do.call(rbind, out)


clade.means <- clade.means[(!clade.means$clade %in% c("Topazes", "Patagona")), ]

ggplot(data = clade.means, aes(x = clade, y = mean)) + geom_bar(stat = "identity", fill = inferno(10)[7]) +
  scale_fill_gradientn(colours = (inferno(10)[2:9])) +
  theme_classic() +
  labs(y = "", x = "Parameter") +
  theme(axis.text.x = element_text(face="bold", angle=45,  hjust = 1)) +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se)) +
  facet_wrap(~var, scales = "free_y", nrow = 4)

```

```{r phylomorphospaces, eval = F, echo = F}

tree<-pbtree(n=26,tip.label=LETTERS)
X<-fastBM(tree,nsim=3)
## Not run: 
phylomorphospace3d(tree,X,control=list(spin=FALSE))

## End(Not run)
phylomorphospace3d(tree, X, method = "static")

```


### Complexity measures

#### Correlation between complexity parameters

```{r distribution of complexity measures, eval = TRUE, echo = FALSE,  fig.width = 8}

ap <- read.csv("Song parameters hummingbirds.csv", stringsAsFactors = FALSE)

cm <- cor(ap[, c("elm.types", "trans.div", "sq.complx", "acous.spc")])

corrplot.mixed(cm, upper = "ellipse", upper.col = rev(viridis::inferno(10)), tl.col = "black", lower.col = rev(viridis::inferno(10))) 
```

#### Phylogenetic PCA on complexity measures:

Variance explained:

```{r explained variance PCA , eval = TRUE, echo = FALSE,  fig.width = 8}

pca.complx <- readRDS("PCA complexity.RDS")

phy.pca.complx <- readRDS("phylogenetic PCA complexity.RDS")

sm.pca <- summary(phy.pca.complx)

# eigs <- pca.complx$sdev^2
# eigs <- eigs / sum(eigs)

pca.df <- data.frame(pc = names(sm.pca$sdev), var = sm.pca$importance[2,])

ggplot(data = pca.df, aes(x = pc, y = var)) + geom_bar(stat = "identity", fill = inferno(10)[c(7, 10, 10, 10)]) +
    theme_classic() +
    labs(y = "Explained variance", x = "Principal component")

```

Loadings:

```{r loadings, eval = TRUE, echo = FALSE,  fig.width = 8}

loads <- phy.pca.complx$L

loads[,1] <- loads[,1] * -1 

prop.loads <- as.data.frame(loads)
prop.loads <- rapply(prop.loads, function(x) x/sum(abs(x)), how = "replace")
prop.loads <- as.matrix(prop.loads)

# corrplot(prop.loads, method = "pie",  is.corr = T, col = viridis::inferno(10)[3:10], tl.col = "black", p.mat = prop.loads, insig = "p-value", sig.level = -1, diag = T) 

loads.lng <- data.frame(var = rownames(loads), pc = paste("PC", rep(1:4, each = 4)), load = c(loads))

ggplot(data = loads.lng, aes(x = var, y = load, fill = load)) + geom_bar(stat = "identity") +
  scale_fill_gradientn(colours = (inferno(10)[2:9])) +
  theme_classic() +
  labs(y = "Loading", x = "Parameter") +
  facet_wrap(~pc)

```

### Map complexity on tree

#### Distribution of PC1 on complexity and category intervals with equal number of species per category

```{r regular pca complexity distribution, eval = FALSE, echo = FALSE,  fig.width = 8}

# read acoustic measures by song
ap <- read.csv("Song parameters hummingbirds.csv", stringsAsFactors = FALSE)

spp.ap <- aggregate(ap[, c("pca.complx", "acous.spc", "elm.types", "sq.complx", "trans.div")], by = list(ap$species_uscr), mean)

spp.ap$clade <- sapply(spp.ap$Group.1, function(x) ap$clade[ap$species_uscr == x][1])

# use quantiles for breaks
# brks <- quantile(spp.ap$pca.complx)
brks <- quantile(spp.ap$pca.complx, probs = c(0, 0.33, 0.66, 1))

# clump firs and second quantile together
if(length(brks) == 5) brks <- brks[-1]
brks[1] <- -Inf
brks[length(brks)] <- Inf

# check distrbution
hist(spp.ap$pca.complx, xlab = "PC1 complexity", col = adjustcolor(viridis(10)[7], 0.4), main = NULL, ylim = c(0, 65), breaks = 30)

rect(xleft = -2, xright = brks[2], ybottom = 0, ytop = 63, col = adjustcolor(inferno(10)[2], 0.2))
rect(xleft = brks[2], xright = brks[3], ybottom = 0, ytop = 63, col = adjustcolor(inferno(10)[9], 0.2))
rect(xleft = brks[3], xright = 7.7, ybottom = 0, ytop = 63, col = adjustcolor(inferno(10)[7], 0.2))

text(x = c(-1.4, 0.2, 4), y = 65, labels = c("Low", "Medium", "High"))

```

```{r phylogenetic pca complexity distribution equal number of species, eval = TRUE, echo = FALSE,  fig.width = 8}

# read acoustic measures by song
phy.pca.complx <- readRDS("phylogenetic PCA complexity.RDS")
ap <- read.csv("Song parameters hummingbirds.csv", stringsAsFactors = FALSE)

spp.ap <- aggregate(ap[, c("acous.spc", "elm.types", "sq.complx", "trans.div")], by = list(ap$species_uscr), mean)

spp.ap$clade <- sapply(spp.ap$Group.1, function(x) ap$clade[ap$species_uscr == x][1])

phy.pca.complx$S[, 1] <-  phy.pca.complx$S[ , 1] * -1

spp.ap$pca.complx <- sapply(1:nrow(spp.ap), function(x) phy.pca.complx$S[rownames(phy.pca.complx$S) == spp.ap$Group.1[x] , 1])

# use quantiles for breaks
# brks <- quantile(spp.ap$pca.complx)
brks <- quantile(spp.ap$pca.complx, probs = c(0, 0.33, 0.66, 1))

# clump firs and second quantile together
if(length(brks) == 5) brks <- brks[-1]
brks[1] <- -Inf
brks[length(brks)] <- Inf

# check distrbution
hist(spp.ap$pca.complx, xlab = "PC1 complexity", col = adjustcolor(viridis(10)[7], 0.4), main = NULL, breaks = 20)

rect(xleft = par("usr")[1], xright = brks[2], ybottom = 0, ytop = par("usr")[4], col = adjustcolor(inferno(10)[2], 0.2))
rect(xleft = brks[2], xright = brks[3], ybottom = 0, ytop = par("usr")[4], col = adjustcolor(inferno(10)[9], 0.2))
rect(xleft = brks[3], xright = par("usr")[2], ybottom = 0, ytop = par("usr")[4], col = adjustcolor(inferno(10)[7], 0.2))

text(x = c(mean(c(par("usr")[1], brks[2])), mean(brks[2:3]), mean(c(par("usr")[2], brks[3]))), y = par("usr")[4], labels = c("Low", "Medium", "High"), pos = 1)

```

```{r phylogenetic pca complexity distribution equal length, eval = TRUE, echo = FALSE,  fig.width = 8}

# read acoustic measures by song
phy.pca.complx <- readRDS("phylogenetic PCA complexity.RDS")
ap <- read.csv("Song parameters hummingbirds.csv", stringsAsFactors = FALSE)

spp.ap <- aggregate(ap[, c("acous.spc", "elm.types", "sq.complx", "trans.div")], by = list(ap$species_uscr), mean)

spp.ap$clade <- sapply(spp.ap$Group.1, function(x) ap$clade[ap$species_uscr == x][1])

phy.pca.complx$S[, 1] <-  phy.pca.complx$S[ , 1] * -1

spp.ap$pca.complx <- sapply(1:nrow(spp.ap), function(x) phy.pca.complx$S[rownames(phy.pca.complx$S) == spp.ap$Group.1[x] , 1])

# use quantiles for breaks
# brks <- quantile(spp.ap$pca.complx)
rng <- range(spp.ap$pca.complx)
brks2 <- (rng[2] - rng[1]) * c(1/3, 2/3)
brks2  <- c(-Inf, brks2 + rng[1], Inf)

# check distrbution
hist(spp.ap$pca.complx, xlab = "PC1 complexity", col = adjustcolor(viridis(10)[7], 0.4), main = NULL, breaks = 20)

rect(xleft = par("usr")[1], xright = brks2[2], ybottom = 0, ytop = par("usr")[4], col = adjustcolor(inferno(10)[2], 0.2))
rect(xleft = brks2[2], xright = brks2[3], ybottom = 0, ytop = par("usr")[4], col = adjustcolor(inferno(10)[9], 0.2))
rect(xleft = brks2[3], xright = par("usr")[2], ybottom = 0, ytop = par("usr")[4], col = adjustcolor(inferno(10)[7], 0.2))

text(x = c(mean(c(par("usr")[1], brks2[2])), mean(brks2[2:3]), mean(c(par("usr")[2], brks2[3]))), y = par("usr")[4], labels = c("Low", "Medium", "High"), pos = 1)

```

#### Correlation of PC1 and individual complexity variables 
```{r correlation PCA and complexity variables, eval=T, echo=F}

# correlation of PCA complexity vs single complexity parameters
cm <- cor(spp.ap[, c( "pca.complx", "sq.complx", "trans.div", "acous.spc", "elm.types")])

# plot correlations
corrplot.mixed(cm, upper = "ellipse", upper.col = rev(viridis::inferno(10)), tl.col = "black", lower.col = rev(viridis::inferno(10))) 

```

#### Phylogenetic signal complexity
```{r, echo = FALSE}
complx <- spp.ap$pca.complx

names(complx) <- spp.ap$Group.1
# read tree
tr339 <- read.tree("imputed hummer tree 339 spp.tre")

tr318 <- drop.tip(tr339, setdiff(tr339$tip.label, spp.ap$Group.1))


phylosig(tr318, x = complx, method = "lambda", test = TRUE)

```


### Complexity-PC1 mapped on phylogeny
 
#### Phylogram 
```{r pca complexity mapped, eval = TRUE, echo = FALSE,  fig.width = 8, fig.height=20}

spp.ap$discrt.cmplx <- cut(spp.ap$pca.complx, breaks = brks, labels = c("Low", "Medium", "High"))

spp.ap$discrt.cmplx2 <- cut(spp.ap$pca.complx, breaks = brks2, labels = c("Low", "Medium", "High"))

spp.ap$discrt.num <- as.numeric(cut(spp.ap$pca.complx, breaks = brks, labels = 1:3))


spp.ap <- spp.ap[match(tr318$tip.label, spp.ap$Group.1), ]

# set cex to match complexity
cx <- spp.ap$discrt.num
cx[cx == 1] <- 0.7
cx[cx == 2] <- 1
cx[cx == 3] <- 1.3

## plot continuous complexity
# plot phylogeny
plot.phylo(tr318, cex = 0.6, edge.width = 2, font = 3, label.offset = 0.6)

# add color labe
tiplabels(bg = inferno(10)[c(4, 9, 7)][spp.ap$discrt.num], cex = cx, pch = 21, offset = 0.35)   

# add legend
add.simmap.legend(leg =  c("Low", "Medium", "High"), colors = inferno(10)[c(4, 9, 7)], prompt = FALSE, fsize = 1, shape = "circle", x = 0.6, 
                    y = 240, cex= 40)

# add clade labels
# add clade labels
for(cld in unique(spp.ap$clade))
cladelabels(tr318, node = if(cld != "Patagona") getMRCA(phy = tr318, tip = tr318$tip.label[spp.ap$clade == cld]) else grep(cld, tr318$tip.label), text = cld, orientation = "horizontal")
```

#### Fan phylogeny
```{r pca complexity mapped fan tree, eval = TRUE, echo = FALSE,  fig.width = 8, fig.height=20}

# plot fan phylo
par(xpd = TRUE)
plot.phylo(tr318, cex = 0.6, edge.width = 2, font = 3, label.offset = 0.6, type = "f", show.tip.label = FALSE)

# add color label
tiplabels(bg = inferno(10)[c(4, 9, 7)][spp.ap$discrt.num], cex = cx, pch = 21, offset = 0.35)   

# add legend
add.simmap.legend(leg =  c("Low", "Medium", "High"), colors = inferno(10)[c(4, 9, 7)], prompt = FALSE, fsize = 1, shape = "circle", x = -34, 
                  y = 19, cex= c(0.7, 1, 1.3))

# add clade labels
for(cld in unique(spp.ap$clade))
arc.cladelabels(tr318, node = if(cld != "Patagona") getMRCA(phy = tr318, tip = tr318$tip.label[spp.ap$clade == cld]) else grep(cld, tr318$tip.label), text = cld, orientation = "horizontal", ln.offset = 1.08, lab.offset = 1.10)

```

```{r fiDiscrete, echo = F, eval = F}

discrt.cmplx1 <- as.numeric(spp.ap$discrt.cmplx)
names(discrt.cmplx1) <- spp.ap$Group.1

discrt.cmplx2 <- as.numeric(spp.ap$discrt.cmplx2)
names(discrt.cmplx2) <- spp.ap$Group.1

# model in which skipping intermidiate states is not possible
cstm <- rbind(c(NA, 1, 0), c(1, NA, 1), c(0, 1, NA))

cstm2 <- rbind(c(NA, 1, 1), c(0, NA, 1), c(0, 0, NA))

cstm3 <- rbind(c(NA, 1, 1), c(2, NA, 1), c(2, 2, NA))

mdls <- list("ER", "SYM", "ARD", "meristic", cstm, cstm2, cstm3)

out1 <- pblapply(mdls, function(x) try_na(fitDiscrete(tr318, discrt.cmplx1, model = x, ncores = 3)))

out2 <- pblapply(mdls, function(x) try_na(fitDiscrete(tr318, discrt.cmplx2, model = x, ncores = 3)))

names(out2) <- names(out1) <- c("ER", "SYM", "ARD", "meristic", "cstm", "cstm2", "cstm3")

# sort(sapply(out, function(x) x$opt$aicc))

# delta AIC
# round(sort(sapply(out, function(x) x$opt$aicc)) - min(sapply(out, function(x) x$opt$aic)), 2)
# 
# out[names(out) %in% c("ER", "cstm", "meristic")]


saveRDS(out1, "discrete complexity transition models fitDiscrete equal number of species.RDS")

saveRDS(out2, "discrete complexity transition models fitDiscrete equal length.RDS")

```

### Discrete trait evolution model (transitions) "equal number of species" complexity

```{r print fiDiscrete equal number, echo = F, eval = T}

out <- readRDS("discrete complexity transition models fitDiscrete equal number of species.RDS")

fitD <- data.frame(model = names(out), AICc = sort(sapply(out, function(x) x$opt$aicc)))

fitD$DeltaAICc <- round(fitD$AICc - min(fitD$AICc), 2)

fitD <- fitD[order(fitD$DeltaAICc), ]

df1 <- knitr::kable(fitD, row.names = F, escape = FALSE, format = "html")
# 
df1 <-  kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 18)

df1 <- row_spec(df1, row = which(fitD$DeltaAICc < 4), bold = T, color = inferno(10)[9])

row_spec(df1, row = which(fitD$DeltaAICc < 4), bold = T, color = inferno(10)[2], background = inferno(10)[4])

```

### Discrete trait evolution model (transitions) "equal length" complexity

```{r print fiDiscrete, echo = F, eval = T}

out <- readRDS("discrete complexity transition models fitDiscrete equal length.RDS")

fitD <- data.frame(model = names(out), AICc = sort(sapply(out, function(x) x$opt$aicc)))

fitD$DeltaAICc <- round(fitD$AICc - min(fitD$AICc), 2)

fitD <- fitD[order(fitD$DeltaAICc), ]

df1 <- knitr::kable(fitD, row.names = F, escape = FALSE, format = "html")
# 
df1 <-  kable_styling(df1, bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, font_size = 18)

df1 <- row_spec(df1, row = which(fitD$DeltaAICc < 4), bold = T, color = inferno(10)[9])

row_spec(df1, row = which(fitD$DeltaAICc < 4), bold = T, color = inferno(10)[2], background = inferno(10)[4])

```

#### MCMC SIMMAP

```{r SIMMAP, echo = F, eval = F}

#https://grokbase.com/t/r/r-sig-phylo/152781jhmj/bimodal-distribution-in-transition-rates-make-simmap-mcmc

# transition cost matrix
# Q<-matrix(c(-2, 1, 1, 1, -2, 1, 1, 1, -2), 3, 3)

# creat complexity variable and name it


discrt.cmplx1 <- as.numeric(spp.ap$discrt.cmplx)
names(discrt.cmplx1) <- spp.ap$Group.1

discrt.cmplx2 <- as.numeric(spp.ap$discrt.cmplx2)
names(discrt.cmplx2) <- spp.ap$Group.1

Nsim <- 100


# add complexity values to phylogeny
# equal rates
# ERtrs1 <- make.simmap(tr318, discrt.cmplx1, model="ER", nsim = Nsim, pi = "estimated", Q = "mcmc")
# 
# saveRDS(ERtrs1, "equal rates MCMC SIMMAP on discrette complexity equal number species categories.RDS")
# 
# ERtrs2 <- make.simmap(tr318, discrt.cmplx2, model="ER", nsim = Nsim, pi = "estimated", Q = "mcmc")
# 
# saveRDS(ERtrs2, "equal rates MCMC SIMMAP on discrette complexity equal length categories.RDS")
# 

ARDtrs1 <- make.simmap(tr318, discrt.cmplx1, model="ARD", nsim = Nsim, pi = "estimated", Q = "mcmc")

saveRDS(ARDtrs1, "different rates MCMC SIMMAP on discrette complexity equal number of species.RDS")

ARDtrs2 <- make.simmap(tr318, discrt.cmplx2, model="ARD", nsim = Nsim, pi = "estimated", Q = "mcmc")

saveRDS(ARDtrs2, "different rates MCMC SIMMAP on discrette complexity equal number length.RDS")


# 
# ARDmtrees
# 
# cols<-setNames(inferno(10)[c(2, 5, 7)],letters[1:nrow(Q)])
# 
# plotSimmap(ERtrs[[1]],cols, pts=F,ftype="off")
# 
# describe.simmap(ERtrs)
# 
# 
# 
# # function to compute the states
# foo<-function(x){
# y<-sapply(x$maps,function(x) names(x)[1])
# names(y)<-x$edge[,1]
# y<-y[as.character(length(x$tip)+1:x$Nnode)]
# return(y)
# }
# 
# AA<-sapply(ERtrs,foo)
# 
# 
# piesA <- t((apply(AA, 1, table)) / Nsim)
# 
# plot(tr318,no.margin=TRUE,show.tip.label=F)
# 
# nodelabels(pie=piesA,cex=0.6,piecol=cols)
# 
# 
# 
# 
# # tree<-pbtree(n=200,scale=1, nsim = 2)
# # Q<-matrix(c(-1,1,1, 1, -1, 1, 1, 1,-1),3,3)
# # rownames(Q)<-colnames(Q)<-letters[1:nrow(Q)]
# # tree<-sim.history(tree[[1]],Q,anc="a")
# mtrees<-make.simmap(tree,tree$states,model="ER", nsim=100,pi="estimated")
# cols<-setNames(inferno(10)[c(2, 5, 7)],letters[1:nrow(Q)])
# plotSimmap(mtrees[[1]],cols,pts=F,ftype="off")
# 
# 
# describe.simmap(mtrees)

```


```{r SIMMAP MCMC ER, eval = F, echo = F}

# Equal rates & "equal number of species"" complexity:

ERtrs <- readRDS("equal rates MCMC SIMMAP on discrette complexity.RDS")

describe.simmap(ERtrs)

Qs <- lapply(ERtrs, "[[", 'Q')

value <- c(sapply(Qs, function(x) x[1, 2]), 
           sapply(Qs, function(x) x[1, 3]), 
           sapply(Qs, function(x) x[2, 3]), 
           sapply(Qs, function(x) x[3, 2]), 
           sapply(Qs, function(x) x[3, 1]), 
           sapply(Qs, function(x) x[2, 1]))

trans.df <- data.frame(trans = rep(c("low.to.med", "low.to.high", "med.to.high", "high.to.med", "high.to.low", "med.to.low"), each = length(Qs)), value)


ggplot(trans.df) + 
    geom_density(data= trans.df[trans.df$trans %in% c("low.to.med", "low.to.high", "med.to.high"), ], alpha = 0.35, aes(x = value, fill = trans)) +         theme_classic() +
   scale_fill_manual(values = inferno(12)[c(1, 3, 5, 7, 9, 11)]) +
   ggtitle("Increasing complexity")+ xlim(range(trans.df$value))


ggplot(trans.df) + 
    geom_density(data= trans.df[trans.df$trans %in% c("high.to.med", "high.to.low", "med.to.low"), ], alpha = 0.35, aes(x = value, fill = trans)) +         theme_classic() +
   scale_fill_manual(values = inferno(12)[c(7, 9, 11)]) +
   ggtitle("Decreasing complexity") + xlim(range(trans.df$value))



```

Different rates "equal number of species" complexity:

```{r SIMMAP MCMC ARD equal number of species, eval = T, echo = F}

ARDtrs <- readRDS("different rates MCMC SIMMAP on discrette complexity equal number of species.RDS")

describe.simmap(ARDtrs)

Qs <- lapply(ARDtrs, "[[", 'Q')

value <- c(sapply(Qs, function(x) x[1, 2]), 
           sapply(Qs, function(x) x[1, 3]), 
           sapply(Qs, function(x) x[2, 3]), 
           sapply(Qs, function(x) x[3, 2]), 
           sapply(Qs, function(x) x[3, 1]), 
           sapply(Qs, function(x) x[2, 1]))

trans.df <- data.frame(trans = rep(c("low.to.med", "low.to.high", "med.to.high", "high.to.med", "high.to.low", "med.to.low"), each = length(Qs)), value)

ggplot(trans.df) + 
    geom_density(data= trans.df[trans.df$trans %in% c("low.to.med", "low.to.high", "med.to.high"), ], alpha = 0.35, aes(x = value, fill = trans)) +         theme_classic() +
   scale_fill_manual(values = inferno(12)[c(1, 3, 5, 7, 9, 11)]) +
   ggtitle("Increasing complexity") + xlim(range(trans.df$value))


ggplot(trans.df) + 
    geom_density(data= trans.df[trans.df$trans %in% c("high.to.med", "high.to.low", "med.to.low"), ], alpha = 0.35, aes(x = value, fill = trans)) +         theme_classic() +
   scale_fill_manual(values = inferno(12)[c(7, 9, 11)]) +
   ggtitle("Decreasing complexity") + xlim(range(trans.df$value))


```

Different rates "equal length" complexity:

```{r SIMMAP MCMC ARD equal length, eval = T, echo = F}

ARDtrs <- readRDS("different rates MCMC SIMMAP on discrette complexity equal number length.RDS")

describe.simmap(ARDtrs)

Qs <- lapply(ARDtrs, "[[", 'Q')

value <- c(sapply(Qs, function(x) x[1, 2]), 
           sapply(Qs, function(x) x[1, 3]), 
           sapply(Qs, function(x) x[2, 3]), 
           sapply(Qs, function(x) x[3, 2]), 
           sapply(Qs, function(x) x[3, 1]), 
           sapply(Qs, function(x) x[2, 1]))

trans.df <- data.frame(trans = rep(c("low.to.med", "low.to.high", "med.to.high", "high.to.med", "high.to.low", "med.to.low"), each = length(Qs)), value)


ggplot(trans.df) + 
    geom_density(data= trans.df[trans.df$trans %in% c("low.to.med", "low.to.high", "med.to.high"), ], alpha = 0.35, aes(x = value, fill = trans)) +         theme_classic() +
   scale_fill_manual(values = inferno(12)[c(1, 3, 5, 7, 9, 11)]) +
   ggtitle("Increasing complexity") + xlim(range(trans.df$value))


ggplot(trans.df) + 
    geom_density(data= trans.df[trans.df$trans %in% c("high.to.med", "high.to.low", "med.to.low"), ], alpha = 0.35, aes(x = value, fill = trans)) +         theme_classic() +
   scale_fill_manual(values = inferno(12)[c(7, 9, 11)]) +
   ggtitle("Decreasing complexity") + xlim(range(trans.df$value))


```


```{r Diver rates, eval=F, echo=T}

tr339 <- read.tree("imputed hummer tree 339 spp.tre")

source('./DR_metric_FUN.R')

DR_metric(tr339)


#simulado
trees <- rmtree(N = 100, n = 200)

drs <- pblapply(trees, DR_metric)

drs <- lapply(drs, function(x) as.data.frame(t(x)))

drs <- do.call(rbind, drs)

# valor promedio por species
colMeans(drs)

hist(colMeans(drs))

```


---

<font size="5">Session information</font>

```{r session info, echo=F}

sessionInfo()


```
